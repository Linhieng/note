## ğŸ• é“¾è¡¨

é“¾è¡¨åˆ†ä¸ºå•é“¾è¡¨å’ŒåŒé“¾è¡¨:
- å•é“¾è¡¨: å•å‘è¿æ¥
- åŒé“¾è¡¨: åŒå‘è¿æ¥

### å°ç»ƒä¹  - åè½¬é“¾è¡¨

ã€é¢˜ç›®ã€‘: åˆ†åˆ«å®ç°åè½¬å•é“¾è¡¨å’Œåè½¬åŒé“¾è¡¨çš„å‡½æ•°ã€‚
ã€è¦æ±‚ã€‘: å¦‚æœé“¾è¡¨é•¿åº¦ä¸º N, è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚

ã€âš ï¸é‡ç‚¹ã€‘ï¼š å½“ä½ æ–­æ‰æŸä¸ªé“¾æ¡æ—¶, ä½ è¦æ¸…æ¥šæ˜¯å¦éœ€è¦ä½¿ç”¨åˆ°æ–­å¼€ä¹‹å‰æ‰€æŒ‡å‘çš„èŠ‚ç‚¹! å¦‚æœéœ€è¦, é‚£ä¹ˆä¸€å®šè¦å…ˆå°†è¯¥èŠ‚ç‚¹å­˜å‚¨èµ·æ¥ï¼

ã€æˆ‘çš„ä»£ç ã€‘ï¼š

```py
def reversed_linked_list(head, is_double=False):
    # åˆ¤æ–­è¾¹ç•Œæ¡ä»¶
    if head is None or head.next is None:
        return head

    # åˆå§‹å€¼
    pr = None
    p = head
    pn = p.next

    while True:
        p.next = pr # åè½¬
        if is_double:
            p.prev = pn # åè½¬åŒé“¾è¡¨åªå¤šäº†è¿™ä¸€æ­¥

        # ç»“æŸåˆ¤æ–­
        if pn is None:
            break

        # æ›´æ–°
        pr = p
        p = pn
        pn = p.next

    return p
```


### å°ç»ƒä¹  - æ‰“å°ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„å…¬å…±éƒ¨åˆ†

ã€é¢˜ç›®ã€‘: ç»™å®šä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„å¤´æŒ‡é’ˆ head1 å’Œ head2, æ‰“å°ä¸¤ä¸ªé“¾è¡¨çš„å…¬å…±éƒ¨åˆ†ã€‚
ã€è¦æ±‚ã€‘: å¦‚æœä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ä¹‹å’Œä¸º N, æ—¶é—´å¤æ‚åº¦è¦æ±‚ä¸º O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦è¦æ±‚ä¸º O(1)ã€‚

ã€ç®—æ³•æ€è·¯ã€‘: ä¸¤ä¸ªæŒ‡é’ˆ, è°å°è°ç§»åŠ¨ã€‚ ç›¸åŒæ—¶æ‰“å°å¹¶ä¸€èµ·ç§»åŠ¨ã€‚ ç›´åˆ°æŸä¸€æŒ‡é’ˆè¶Šç•Œã€‚

ã€æˆ‘çš„ä»£ç ã€‘:
```py
def linked_list_common(head1, head2):
    common = []
    while head1 is not None and head2 is not None:
        if head1.data < head2.data:
            head1 = head1.next
        elif head1.data > head2.data:
            head2 = head2.next
        else:
            common.append(head1.data)
            head1 = head1.next
            head2 = head2.next
    return common
```

### é¢è¯•æ—¶é“¾è¡¨è§£é¢˜æ–¹æ³•è®º

ç¬”è¯•å’Œé¢è¯•è¦æ±‚ä¸ä¸€æ ·ã€‚
- ç¬”è¯•: èƒ½è¿‡å°±è¡Œ, æ²¡äººçœ‹ä½ ä»£ç ã€‚ æ‰€ä»¥ä¸ç”¨å¤ªåœ¨ä¹ç©ºé—´å¤æ‚åº¦, ä¸€åˆ‡ä¸ºäº†æ—¶é—´å¤æ‚åº¦ã€‚
- é¢è¯•: æ—¶é—´å¤æ‚åº¦ä»ç„¶æ˜¯ç¬¬ä¸€ä½, ä½†æ˜¯ç©ºé—´å¤æ‚åº¦ä¸€å®šè¦çœã€‚ å› ä¸ºæ­¤æ—¶çœ‹ä½ çš„ä¸æ˜¯æœºå™¨, æ˜¯é¢è¯•å®˜ã€‚

ã€æŠ€å·§ã€‘:
- é¢å¤–æ•°æ®ç»“æ„è®°å½•(å“ˆå¸Œè¡¨ç­‰)
- å¿«æ…¢æŒ‡é’ˆã€‚ æ¯”å¦‚ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸€æ­¥, ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸¤æ­¥ã€‚

### ç»ƒä¹  - åˆ¤æ–­å•é“¾è¡¨å›æ–‡

ã€åšæ³•1(ç¬”è¯•)ã€‘: å…ˆéå†ä¸€éé“¾è¡¨, å¹¶æŠŠå€¼ä¾æ¬¡æ”¾å…¥æ ˆä¸­ã€‚ å†éå†ä¸€éé“¾è¡¨, æ­¤æ—¶æ¯æ¬¡éå†éƒ½å°†æ ˆçš„å†…å®¹å¼¹å‡º, ç„¶åæ¯”è¾ƒæ˜¯å¦ç›¸ç­‰ã€‚ ç›´åˆ°ä¸ç›¸ç­‰æˆ–è€…æ ˆä¸ºç©ºã€‚

ã€åšæ³•2(ç¬”è¯•)ã€‘:
åšæ³• 1 ä¸­éå†äº†ä¸¤éé“¾è¡¨, è€Œä¸”æ ˆå ç”¨çš„ç©ºé—´å¤§å°ä¸º Nã€‚
ä½†å®é™…ä¸Š, å½“æˆ‘ä»¬éå†åˆ°é“¾è¡¨ä¸­é—´ä¹‹å, å°±å¯ä»¥å°†æ ˆä¸­çš„å…ƒç´  pop å‡ºæ¥å’Œé“¾è¡¨è¿›è¡Œæ¯”è¾ƒäº†ã€‚
é—®é¢˜åœ¨äº, å¦‚ä½•ç¡®å®šä¸­é—´ä½ç½®? æ–¹æ³•å°±æ˜¯ **å¿«æ…¢æŒ‡é’ˆ**ã€‚
ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸€æ­¥, ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸¤æ­¥ã€‚ å½“å¿«æŒ‡é’ˆåˆ°å¤´æ—¶, å°±è¯´æ˜åˆ°ä¸­é—´é™„è¿‘äº†ã€‚

ã€åšæ³•3(é¢è¯•)ã€‘:ä¸å€ŸåŠ©æ ˆå®ç°:
1. æ‰¾åˆ°ä¸­é—´ä½ç½®
2. ä»ä¸­é—´, å°†åé¢çš„é“¾è¡¨èŠ‚ç‚¹åè½¬ã€‚
3. ä»é“¾è¡¨ä¸¤ç«¯å¾€ä¸­é—´ä¸€ä¸€æ¯”è¾ƒ, å³é“¾è¡¨åœ¨æ¯”è¾ƒçš„è¿‡ç¨‹ä¸­å†æ¬¡å°†é“¾è¡¨åè½¬

ã€æ³¨æ„âš ï¸ã€‘: æ€è·¯éƒ½å¾ˆç®€å•, éœ€è¦æ³¨æ„çš„åªæœ‰é•¿åº¦å¥‡å¶æ•°æƒ…å†µä¸‹, ä¸­ç‚¹çš„é€‰å–ã€‚ æ ¹æ®é¢˜æ„çš„ä¸åŒ, é€‰å–çš„æ–¹å¼ä¹Ÿä¸åŒã€‚

#### è€å¸ˆä»£ç 

```java
// æ–¹æ³•1
public static boolean isPalindrome1(Node head) {
    Stack<Node> stack = new Stack<Node>();
    Node cur = head;
    // å°†é“¾è¡¨æ‰€æœ‰èŠ‚ç‚¹å…¥æ ˆ
    while (cur != null) {
        stack.push(cur);
        cur = cur.next;
    }
    // å†æ¬¡éå†é“¾è¡¨, å¹¶ä»æ ˆä¸­å…ƒç´ ä¸€ä¸€æ¯”è¾ƒ
    while (head != null) {
        if (head.value != stack.pop().value) {
            return false;
        }
        head = head.next;
    }
    return true;
}

// æ–¹æ³•2
public static boolean isPalindrome2(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    Node right = head.next;
    Node cur = head;
    // æ‰¾åˆ°ä¸­ç‚¹ä½ç½®
    while (cur.next != null && nul.next.next != null) {
        right = right.next;
        cur = cur.next.next;
    }
    // ä»ä¸­ç‚¹ä½ç½®å†å¼€å§‹å°†å…ƒç´ å…¥æ ˆ
    Stack<Node> stack = new Stack<Node>();
    while (right != null) {
        stack.push(right);
        right = right.next;
    }
    // å†æ¬¡éå†, ä¸€ä¸€æ¯”è¾ƒ
    while (!stack.isEmpty()) {
        if (head.value != stack.pop().value) {
            return false;
        }
        head = head.next;
    }
}

// æ–¹æ³•3
public static boolean isPalindrome3(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    Node n1 = head;
    Node n2 = head;
    // å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­é—´
    while (n2.next != null && n2.next.next != null) {
        n1 = n1.next;
        n2 = n2.next.next;
    }
    // åè½¬ååŠé“¾è¡¨
    n2 = n1.next;
    n1.next = null;
    Node n3 = null;
    while (n2 != null) {
        n3 = n3.next;
        n2.next = n1;
        n2 = n3;
    }
    // ä»é“¾è¡¨ä¸¤ç«¯å‘ä¸­é—´ä¸€ä¸€æ¯”è¾ƒ
    n3 = n1;
    n2 = head;
    boolean res = true;
    while (n1 != null && n2 != null) {
        if (n1.value != n2.value) {
            res = false;
            break;
        }
        n1 = n1.next;
        n2 = n2.next;
    }
    // å®Œæˆåå†æ¬¡æŠŠååŠé“¾è¡¨åè½¬
    n1 = n3.next;
    n3.next = null;
    while (n1 != null) {
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
    }
}

```

#### æˆ‘çš„ä»£ç 


```py
def is_palindrome_linked_list2(head):
    if head is None:
        return False
    if head.next is None:
        return True
    # åˆ©ç”¨å¿«æ…¢æŒ‡é’ˆ, èµ°åˆ°ä¸­ç‚¹å°±å¼€å§‹å‡ºæ ˆæ¯”è¾ƒ
    slow = head
    quick = head.next
    mid_r = None  # å¶:åå³; å¥‡:ä¸­ç‚¹å³è¾¹
    half_stack = []  # åªä¼šå¡«å……å·¦ä¾§ã€‚ å¶:å¡«ä¸€åŠ; å¥‡:ä¸åŒ…å«ä¸­ç‚¹
    while True:
        half_stack.append(slow.data)
        if quick.next is None:  # å¶
            mid_r = slow.next
            break
        if quick.next.next is None:  # å¥‡
            mid_r = slow.next.next
            break
        slow = slow.next
        quick = quick.next.next
    while mid_r is not None:
        if (mid_r.data != half_stack.pop()):
            return False
        mid_r = mid_r.next
    return True


def is_palindrome_linked_list3(head):
    if head is None:
        return False
    if head.next is None:
        return True
    # ä¸å€ŸåŠ©æ ˆ, è¿‡äº†ä¸­ç‚¹åå°†é“¾è¡¨åè½¬
    # ç„¶åä»é“¾è¡¨ä¸¤ä¾§å¾€å›ä¸€ä¸€æ¯”è¾ƒ, å¾€å›èµ°æ—¶å†æ¬¡åè½¬é“¾è¡¨
    slow = head
    quick = head.next
    mid_r = None
    while True:
        if quick.next is None:
            mid_r = slow.next
            break
        if quick.next.next is None:
            mid_r = slow.next.next
            break
        slow = slow.next
        quick = quick.next.next
    # ä» mid_r èŠ‚ç‚¹å¼€å§‹è¿›è¡Œåè½¬
    pr, p, pn = None, mid_r, mid_r.next
    while True:
        p.next = pr
        if pn is None:
            break
        pr = p
        p = pn
        pn = p.next
    # æ­¤æ—¶çš„ p æ˜¯å³é“¾è¡¨å¤´èŠ‚ç‚¹, mid_r æ˜¯å°¾èŠ‚ç‚¹
    # ç°åœ¨å†æ¬¡åè½¬å³é“¾è¡¨, åœ¨åè½¬çš„è¿‡ç¨‹ä¸­ä¸å·¦é“¾è¡¨ä¸€ä¸€æ¯”è¾ƒ
    left = head
    pr, p, pn = None, p, p.next
    is_palindrome = True
    while True:
        if left.data != p.data:
            is_palindrome = False
        p.next = pr
        if pn is None:
            break
        pr = p
        p = pn
        pn = p.next
        left = left.next
    return is_palindrome
```

### ç»ƒä¹  - å¯¹å•é“¾è¡¨çš„å€¼è¿›è¡Œåˆ’åˆ†

ã€é¢˜ç›®ã€‘: ç»™å®šä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head, èŠ‚ç‚¹çš„å€¼ç±»å‹æ˜¯æ•´å‹, å†ç»™å®šä¸€ä¸ªæ•´æ•° pivotã€‚
å®ç°ä¸€ä¸ªè°ƒæ•´é“¾è¡¨çš„å‡½æ•°, å°†é“¾è¡¨è°ƒæ•´ä¸ºå·¦éƒ¨åˆ†éƒ½æ˜¯å€¼å°äº pivot çš„èŠ‚ç‚¹, ä¸­é—´éƒ¨åˆ†éƒ½æ˜¯å€¼ç­‰äº pivot çš„èŠ‚ç‚¹, å³éƒ¨åˆ†éƒ½æ˜¯å€¼å¤§äº pivot çš„èŠ‚ç‚¹ã€‚
ã€è¿›é˜¶ã€‘: è¦æ±‚å®ç°ç¨³å®šæ€§, åŒæ—¶æ—¶é—´å¤æ‚åº¦ä¸º O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚

ã€åšæ³• 1(ç¬”è¯•)ã€‘: æŠŠå•é“¾è¡¨è½¬æ¢ä¸ºæ•°ç»„, ç„¶ååšå¿«æ’çš„ partitionã€‚ åšå®Œåå†æŠŠæ•°ç»„è½¬æ¢ä¸ºå•é“¾è¡¨

ã€åšæ³• 2(é¢è¯•)ã€‘:
å®šä¹‰ä¸‰ä¸ªåŒºåŸŸçš„ç©ºé“¾è¡¨ã€‚ éå†é“¾è¡¨, å°†æ¯æ¬¡éå†åˆ°çš„èŠ‚ç‚¹æ”¾åˆ°æ­£ç¡®çš„åŒºåŸŸå†…ã€‚ éå†å®Œæˆåå°†ä¸‰ä¸ªåŒºåŸŸçš„é“¾è¡¨è¿æ¥èµ·æ¥å°±å¯ä»¥äº†ã€‚

ç”±äºé“¾è¡¨ä¸­èŠ‚ç‚¹çš„ç§»åŠ¨ä»£ä»·æ˜¯ O(1), æ‰€ä»¥ä»…éœ€æœ‰é™çš„å‡ ä¸ªå˜é‡å°±å®ç°é“¾è¡¨ partitionã€‚

ã€ä»£ç æ€è·¯ã€‘ï¼š
1. å®šä¹‰ 6 ä¸ªå˜é‡, SH è¡¨ç¤º "< åŒº" çš„å¤´èŠ‚ç‚¹, ST è¡¨ç¤º "<" åŒºåŸŸçš„å°¾èŠ‚ç‚¹ã€‚ åŒç†è¿˜æœ‰ "= åŒº" çš„ä¸¤ä¸ªèŠ‚ç‚¹ EH å’Œ ET,   "> åŒº" çš„ä¸¤ä¸ªèŠ‚ç‚¹ BH å’Œ BTã€‚ ä»–ä»¬çš„åˆå§‹å€¼éƒ½æ˜¯ç©ºã€‚
2. éå†é“¾è¡¨
3. å½“èŠ‚ç‚¹ < åˆ’åˆ†å€¼æ—¶, å°†èŠ‚ç‚¹æ”¾åˆ° "< åŒº" çš„é“¾è¡¨ä¸Šã€‚å…·ä½“åšæ³•æ˜¯: ç¬¬ä¸€ä¸ªå°äºåˆ’åˆ†å€¼çš„èŠ‚ç‚¹, å°†å®ƒåŒæ—¶èµ‹å€¼ç»™ SH å’Œ ST, ç„¶å SH å°±ä¸ç”¨å˜äº†ã€‚ åç»­å†é‡åˆ°ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹æ—¶, å°†å®ƒä½œä¸º ST çš„ä¸‹ä¸€èŠ‚ç‚¹, åŒæ—¶ ST å‘ä¸‹ç§»åŠ¨, ä»¥æ­¤ç±»æ¨ã€‚
4. å½“èŠ‚ç‚¹ == åˆ’åˆ†å€¼æˆ–èŠ‚ç‚¹ > åˆ’åˆ†å€¼ æ—¶, éƒ½æ˜¯åŒæ ·çš„åšæ³•ã€‚
5. ç»“æŸæ—¶, å°†ä¸‰æ¡é“¾è¡¨è¿æ¥èµ·æ¥ã€‚ å…·ä½“åšæ³•:
    - åœ¨ ST ä¸ä¸ºç©ºæ—¶: è‹¥ EH ä¸ä¸ºç©º, åˆ™ ST è¿æ¥ EH, å¦åˆ™è¿æ¥ BHã€‚ ä¸éœ€è¦å†åˆ¤æ–­ BH æ˜¯å¦ä¸ºç©ºã€‚
    - åœ¨ ET ä¸ä¸ºç©ºæ—¶, ET åªä¼šè¿æ¥ BHã€‚
    - åœ¨ BT ä¸ä¸ºç©ºæ—¶, BT å¿…é¡»è¿æ¥"ç©º"ã€‚
    - è¿æ¥å¥½å„è‡ªçš„å°¾éƒ¨å, åªéœ€è¦æ”¾å›ä¸‰æ¡é“¾è¡¨ä¸­çš„ä¸€ä¸ªå¤´èŠ‚ç‚¹å³å¯, ä¸‰ä¸ªå¤´èŠ‚ç‚¹çš„ä¼˜å…ˆçº§æ˜¯ SH > EH > BHã€‚

#### è€å¸ˆä»£ç 

```java
// æ–¹æ³•1
public static Node listPartition1(Node head, int pivot) {
    if (head == null) {
        return head;
    }
    Node cur = head;
    // è·å–é“¾è¡¨é•¿åº¦
    int i = 0;
    while (cur != null) {
        i++;
        cur = cur.next;
    }
    // å°†é“¾è¡¨è½¬æ¢ä¸ºæ•°ç»„
    Node[] nodeArr = new Node[i];
    i = 0;
    cur = head;
    for (i = 0; i != nodeArr.length; i++) {
        nodeArr[i] = cur;
        cur = cur.next;
    }
    // åœ¨æ•°ç»„ä¸Šæ‰§è¡Œ partition
    arrPartition(nodeArr, pivot);
    // å°†æ•°ç»„é‡æ–°è¿æ¥æˆé“¾è¡¨
    for (i = 1; i != nodeArr.length; i++) {
        nodeArr[i - 1].next = nodeArr[i];
    }
    nodeArr[i - 1].next = null;
    return nodeArr[0];
}

public static void arrPartition(Node[] nodeArr, int pivot) {
    int small = -1;
    int big = nodeArr.length;
    int index = 0;
    while (index != big) {
        if (nodeArr[index].value < pivot) {
            swap(nodeArr, ++small; index++);
        } else if (nodeArr[index].value == pivot) {
            index ++;
        } else {
            swap(nodeArr, --big, index);
        }
    }
}

// æ–¹æ³•2
public static Node listPartition2(Node head, int pivot) {
    // åˆ›å»ºä¸‰æ¡é“¾è¡¨, åˆ†åˆ«å­˜æ”¾ä¸‰ç±»å€¼
    Node sH = null; // small head
    Node sT = null; // small tail
    Node eH = null;
    Node eT = null;
    Node bH = null;
    Node bT = null;
    Node next = null; // save next node

    // å°†èŠ‚ç‚¹åˆ†åˆ«æ”¾å…¥ä¸‰ç±»é“¾è¡¨ä¸Š
    while (head != null) {
        next = head.next;
        head.next = null;
        if (head.value < pivot) {
            if (sH == null) {
                sH = head;
                sT = head;
            } else {
                sT.next = head;
                sT = head;
            }
        } else if (head.value == pivot) {
            if (eH == null) {
                eH = head;
                eT = head;
            } else {
                eT.next = head;
                eT = head;
            }

        } else {
            if (bH == null) {
                bH = head;
                bT = head;
            } else {
                bT.next = head;
                bT = head;
            }
        }
        head = next;
    }


    if (sT != null) {
        // è‹¥æœ‰ s, s ç›´æ¥è¿ eH
        sT.next = eH;
        // æ­¤æ—¶è¦æ˜¯ eH æ²¡æœ‰, ä¸‹ä¸€ä¸ª if ä¼šæ•è·åˆ°, å¹¶æŠŠ s é‡æ–°è¿åˆ° b
        // è¦æ˜¯ e æœ‰,                       é‚£ä¹ˆ e å°±éœ€è¦è¿åˆ° b
        // ä¹Ÿå°±æ˜¯, ä¸ç®¡ e æœ‰æ²¡æœ‰, éƒ½éœ€è¦æœ‰äººè¿æ¥åˆ° b, è¦ä¹ˆæ˜¯ s è¿, è¦ä¹ˆæ˜¯ e è¿
        eT = eT == null ? sT : eT;
        // æ­¤æ—¶çš„ eT å¯èƒ½æ˜¯ s, ä¹Ÿå¯èƒ½æ˜¯ e
    }
    // å¦‚æœä¸Šä¸€ä¸ª if è¿›å»äº†, é‚£ä¹ˆè¿™é‡Œçš„ if ä¹Ÿä¸€å®šä¼šè¿›å»
    // å¦‚æœä¸Šä¸€ä¸ª if æ²¡è¿›å», é‚£ä¹ˆè¿™é‡Œçš„ if å¯èƒ½ä¼šè¿›å»
    if (eT != null) {
        eT.next = bH;
    }

    // è¿æ¥é¡ºåºæ˜¯ s-e-b, è¦æ˜¯æ²¡æœ‰ sH, é‚£å°±è¿”å› eH, è¦æ˜¯ eH ä¹Ÿæ²¡æœ‰, é‚£å°±è¿”å› bH
    // æ‰€ä»¥å‰é¢ä¸¤ä¸ª if åªéœ€è¦ç¡®ä¿ä¸‰ä¸ªåŒºåŸŸèƒ½è¿æ¥èµ·æ¥å°±å¯ä»¥ã€‚
    return sH != null ? sH : (eH != null ? eH : bH);
}

```

#### æˆ‘çš„ä»£ç 
```py
def linked_list_partition2(head, pivot):
    # ç¨³å®š
    if head is None or head.next is None:
        return head

    # åˆ›å»ºä¸‰æ¡é“¾è¡¨, åˆ†åˆ«å­˜æ”¾å¤§äºç­‰äºå°äº
    lH, lT = None, None
    eH, eT = None, None
    mH, mT = None, None
    p = head
    while p is not None:
        if p.data < pivot:
            if lH is None:
                lH = lT = p
            else:
                lT.next = p
                lT = p
        elif p.data == pivot:
            if eH is None:
                eH = eT = p
            else:
                eT.next = p
                eT = p
        else:
            if mH is None:
                mH = mT = p
            else:
                mT.next = p
                mT = p
        p = p.next

    # å°†ä¸‰æ¡é“¾è¡¨è¿åœ¨ä¸€èµ·ã€‚ åªéœ€è¦å¯¹ tail.next è¿›è¡Œæ“ä½œ
    if lT is not None:  # lT è¦ä¹ˆè¿ eH, è¦ä¹ˆè¿ mHã€‚ (è‡ªåŠ¨åŒ…å«äº† None çš„æƒ…å†µ)
        lT.next = eH if eH is not None else mH
    if eT is not None:  # eT åªä¼šè¿ mH (è‡ªåŠ¨åŒ…å«äº† None çš„æƒ…å†µ)
        eT.next = mH
    if mT is not None:  # mT åªä¼šè¿ None
        mT.next = None

    # åªéœ€è¿”å›ä¸‰ä¸ªå¤´ä¸­çš„ä¸€ä¸ª, ä¼˜å…ˆçº§æ˜¯ lH > eH > mH
    return lH if lH is not None else (eH if eH is not None else mH)

```


### ç»ƒä¹  - å¤åˆ¶å«æœ‰éšæœºæŒ‡é’ˆèŠ‚ç‚¹çš„é“¾è¡¨

ã€é¢˜ç›®ã€‘: ä¸€ç§ç‰¹æ®Šçš„å•é“¾è¡¨èŠ‚ç‚¹ç±»æè¿°å¦‚ä¸‹
```java
class Node {
    int value;
    Node next;
    Node rand;
    Node(int val){
        value = val;
    }
}
```
rand æŒ‡é’ˆæ˜¯å•é“¾è¡¨èŠ‚ç‚¹ç»“æ„ä¸­æ–°å¢çš„æŒ‡é’ˆ, rand å¯èƒ½æŒ‡å‘é“¾è¡¨ä¸­çš„ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹, ä¹Ÿå¯èƒ½æŒ‡å‘ nullã€‚
ç»™å®šä¸€ä¸ªç”± Node èŠ‚ç‚¹ç±»å‹ç»„æˆçš„æ— ç¯å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head, è¯·å®ç°ä¸€ä¸ªå‡½æ•°å®Œæˆè¿™ä¸ªé“¾è¡¨çš„å¤åˆ¶, å¹¶è¿”å›å¤åˆ¶çš„æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹
```
   â•­ ---------- rand -------â•®
   â†“                        â†‘
â•­  â”€  â•®     â•­  â”€  â•®      â•­  â”€  â•®
â”‚     â”‚ --> â”‚     â”‚ -->  â”‚     â”‚ --> ....
â•°  â”€  â•¯     â•°  â”€  â•¯      â•°  â”€  â•¯

```
ã€è¦æ±‚ã€‘: æ—¶é—´å¤æ‚åº¦ O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦ O(1)

ã€è§£é‡Šé¢˜ç›®ã€‘: è¿™ä¸ªé“¾è¡¨å’Œæ™®é€šé“¾è¡¨çš„åŒºåˆ«åœ¨äº, ä»–å¤šäº† rand è¿™ä¸ªå±æ€§ã€‚ å½“æˆ‘ä»¬å¤åˆ¶é“¾è¡¨æ—¶, è¦æ±‚æŠŠæ¯ä¸ªèŠ‚ç‚¹ä¸Šçš„ rand çš„æŒ‡å‘ä¹ŸæˆåŠŸå¤åˆ¶ã€‚

ã€åšæ³• 1(ç¬”è®°)ã€‘: åˆ›å»ºä¸€ä¸ª Map, å®ƒçš„ key æ˜¯æ—§é“¾è¡¨èŠ‚ç‚¹, value æ˜¯æ–°èŠ‚ç‚¹(å³æ—§èŠ‚ç‚¹çš„å…‹éš†ä½“)ã€‚ å…ˆéå†ä¸€éé“¾è¡¨, å®Œæˆæ‰€æœ‰èŠ‚ç‚¹å€¼çš„æ‹·è´, æ­¤æ—¶çš„æ‹·è´å¹¶ä¸åŒ…å« next å’Œ randã€‚ å†éå†æ—§é“¾è¡¨, é€šè¿‡æ—§é“¾è¡¨è·å– next èŠ‚ç‚¹å’Œ rand èŠ‚ç‚¹, å°†æ—§é“¾è¡¨çš„èŠ‚ç‚¹ä½œä¸º key, å¯ä»¥è·å–å°±èŠ‚ç‚¹æ‰€å¯¹åº”çš„æ–°èŠ‚ç‚¹çš„åœ°å€, ç„¶åå°†æ–°èŠ‚ç‚¹çš„åœ°å€èµ‹å€¼ç»™ æ–°èŠ‚ç‚¹çš„ next å’Œ randã€‚

ã€åšæ³• 2(é¢è¯•)ã€‘:
å¦‚æœä¸å€ŸåŠ© Map ä¿å­˜å…‹éš†å‡ºæ¥çš„æ–°èŠ‚ç‚¹, é‚£ä¹ˆå°±éœ€è¦æ€è€ƒ: å…‹éš†å‡ºæ¥çš„æ–°èŠ‚ç‚¹è¦æ”¾åœ¨å“ªé‡Œèƒ½ä¸å ç”¨é¢å¤–ç©ºé—´, å¹¶ä¸”è¿˜èƒ½æ ¹æ®æ—§èŠ‚ç‚¹æ‰¾åˆ°å¯¹åº”çš„å…‹éš†èŠ‚ç‚¹?
ç­”æ¡ˆå°±æ˜¯å°†å…‹éš†èŠ‚ç‚¹æ’å…¥åˆ°æ—§èŠ‚ç‚¹ä¹‹å! å…·ä½“åšæ³•å¦‚ä¸‹:
1. ç¬¬ä¸€æ¬¡éå†é“¾è¡¨, åˆ›å»ºå…‹éš†èŠ‚ç‚¹å¹¶å°†å…¶æ’åœ¨å¯¹åº”æ—§èŠ‚ç‚¹ä¹‹å
2. ç¬¬äºŒæ¬¡éå†é“¾è¡¨, ä¸ºå…‹éš†èŠ‚ç‚¹æ‰¾åˆ°ä»–ä»¬çš„ rand èŠ‚ç‚¹æ‰€å¯¹åº”çš„å…‹éš†èŠ‚ç‚¹ã€‚ (å…‹éš† rand èŠ‚ç‚¹ åœ¨ rand èŠ‚ç‚¹çš„ next ä¸­)
3. ç¬¬ä¸‰æ¬¡éå†é“¾è¡¨, å°†å…‹éš†èŠ‚ç‚¹ä»ä¸­æŠ½å‡ºå‡ºæ¥
- æ³¨æ„: ç¬¬äºŒæ¬¡éå†é“¾è¡¨å’Œç¬¬ä¸‰æ¬¡éå†é“¾è¡¨ä¸èƒ½åˆå¹¶åœ¨ä¸€æ¬¡éå†ä¸­ã€‚ å› ä¸º rand èŠ‚ç‚¹æ˜¯éšæœºçš„, å¦‚æœæ‰¾åˆ°ä¸€ä¸ªå…‹éš†èŠ‚ç‚¹çš„ rand èŠ‚ç‚¹åå°±å°†è¯¥å…‹éš†èŠ‚ç‚¹æŠ½ç¦»å‡ºæ¥, é‚£ä¹ˆåé¢çš„èŠ‚ç‚¹å°±å¯èƒ½æ‰¾ä¸åˆ°å®ƒçš„å…‹éš† rand èŠ‚ç‚¹äº†ã€‚

```
â•­  â”€  â•®                 â•­  â”€  â•®                 â•­  â”€  â•®                 â•­  â”€  â•®                 â•­  â”€  â•®
â”‚old1 â”‚      -->        â”‚old2 â”‚      -->        â”‚old3 â”‚      -->        â”‚old4 â”‚      -->        â”‚old5 â”‚      -->        ....
â•°  â”€  â•¯                 â•°  â”€  â•¯                 â•°  â”€  â•¯                 â•°  â”€  â•¯                 â•°  â”€  â•¯
å°†æ–°å…‹éš†çš„èŠ‚ç‚¹æ”¾åˆ°æ—§é“¾è¡¨ä¸Š
â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®
â”‚old1 â”‚ --> â”‚ new1â”‚ --> â”‚old2 â”‚ --> â”‚ new2â”‚ --> â”‚old3 â”‚ --> â”‚ new3â”‚ --> â”‚old4 â”‚ --> â”‚ new4â”‚ --> â”‚old5 â”‚ --> â”‚ new5â”‚ ---> ....
â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯
```

#### è€å¸ˆä»£ç :

```java
// åšæ³•1
public static Node copyListWithRand1(Node head) {
    HashMap<Node, Node> map = new HashMap<Node, Node>();

    // ç¬¬ä¸€æ¬¡éå†: æ‹·è´æ‰€æœ‰æ—§èŠ‚ç‚¹
    Node cur = head;
    while (cur != null) {
        map.put(cur, new Node(cur.value));
        cur = cur.next;
    }

    // ç¬¬äºŒæ¬¡éå†: ä¸ºæ–°èŠ‚ç‚¹çš„ next å’Œ rand èµ‹å€¼æ–°èŠ‚ç‚¹çš„å¼•ç”¨
    cur = head;
    while (cur != null) {
        // å°†æ—§èŠ‚ç‚¹çš„ next èŠ‚ç‚¹ æ‰€å¯¹åº”çš„æ–°èŠ‚ç‚¹å¤åˆ¶ç»™æ–°èŠ‚ç‚¹çš„ next
        map.get(cur).next = map.get(cur.next);
        mpa.get(cur).rand = map.get(cur.rand);
        cur = cur.next;
    }
    return map.get(head);
}

// åšæ³•2
public static Node copyListWithRand2(Node head) {
    if (head == null) {
        return null;
    }

    // 1. å°†æ–°åˆ›å»ºçš„å…‹éš†èŠ‚ç‚¹æ”¾åˆ°æ—§é“¾è¡¨ä¸Šã€‚
    Node cur = head;
    Node next = null;
    while (cur != null) {
        next = cur.next;
        cur.next = new Node(cur.value);
        cur.next.next = next;
        cur = next;
    }

    // 2. ä¸ºæ–°åˆ›å»ºçš„å…‹éš†èŠ‚ç‚¹çš„ rand èµ‹å€¼
    cur = head;
    Node curCopy = null;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        curCopy.rand = cur.rand != null? cur.rand.next : null;
        cur = next;
    }

    // 3. å°†å…‹éš†é“¾è¡¨æŠ½ç¦»å‡ºæ¥
    Node res = head.next;
    cur = head;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = next;
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return res;

}
```

#### æˆ‘çš„ä»£ç 

```py
def copy_random_node_linked_list2(head):
    if head is None:
        return None
    # 1. åˆ›å»ºå…‹éš†èŠ‚ç‚¹å¹¶å°†å®ƒä»¬æ’å…¥åˆ°æºèŠ‚ç‚¹å
    p = head
    while p is not None:
        p_copy = Node(p.data)
        p_copy.next = p.next
        p.next = p_copy
        p = p_copy.next
    # 2. æ‰¾åˆ°å…‹éš†èŠ‚ç‚¹çš„ rand æ‰€å¯¹åº”çš„å…‹éš† rand èŠ‚ç‚¹
    p = head
    while p is not None:
        p_copy = p.next
        pn = p.next.next
        if p.rand is not None:
            p_copy.rand = p.rand.next
        p = pn
    # 3. å°†å…‹éš†èŠ‚ç‚¹æŠ½ç¦»å‡ºæ¥
    p = head
    copy_head = p.next
    while p is not None:
        p_copy = p.next
        pn = p.next.next
        p_copy.next = pn.next if pn is not None else None
        p.next = pn
        p = pn
    return copy_head
```

### ç»ƒä¹  - ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤

ã€é¢˜ç›®ã€‘: ç»™å®šä¸¤ä¸ªå¯èƒ½æœ‰ç¯ä¹Ÿå¯èƒ½æ— ç¯çš„å•é“¾è¡¨, å¤´èŠ‚ç‚¹ head1 å’Œ head2 ã€‚ è¯·å®ç°ä¸€ä¸ªå‡½æ•°, å¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤, è¯·è¿”å›ç›¸äº¤çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœä¸ç›¸äº¤, è¿”å›ç©º
ã€è¦æ±‚ã€‘: å¦‚æœä¸¤ä¸ªé“¾è¡¨é•¿åº¦ä¹‹å’Œä¸º N, æ—¶é—´å¤æ‚åº¦è¯·è¾¾åˆ° O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦è¯·è¾¾åˆ° O(1)ã€‚

å…ˆåˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦æœ‰ç¯

#### åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯

å¯¹äºé“¾è¡¨ç»“æ„, ä»–åªä¼šæœ‰ä¸€ä¸ª next èŠ‚ç‚¹ã€‚ æ‰€ä»¥:
- å¦‚æœæ— ç¯, åˆ™ä¸€å®šä¼šè¾¾åˆ°ç©º
- å¦‚æœæœ‰ç¯, åˆ™ä¸€å®šä¼šé‡åˆ°é‡å¤çš„èŠ‚ç‚¹


ã€æ–¹æ³•1ã€‘: åˆ©ç”¨ Set å“ˆå¸Œè¡¨ã€‚ éå†é“¾è¡¨, æ¯æ¬¡éå†è¿‡ç¨‹ä¸­, å…ˆåˆ¤æ–­æ˜¯å¦å·²å­˜åœ¨è¯¥èŠ‚ç‚¹, ç„¶åå°†è¯¥èŠ‚ç‚¹åŠ åˆ° Set ä¸­ã€‚å¦‚æœå·²å­˜åœ¨, åˆ™æœ‰ç¯, å¦‚æœéå†åˆ°ç©º, åˆ™æ— ç¯ã€‚

ã€æ–¹æ³•2(åªç»™æ­¥éª¤)ã€‘: æ— ç¯æ—¶, å¿«æŒ‡é’ˆç›´æ¥åˆ°ç©ºã€‚ æœ‰ç¯æ—¶, åˆ™:
- å¿«æŒ‡é’ˆæ…¢æŒ‡é’ˆéƒ½ä»å¤´èŠ‚ç‚¹å‡ºå‘, å¿«æŒ‡é’ˆä¸€æ¬¡èµ°ä¸¤æ­¥, æ…¢æŒ‡é’ˆä¸€æ¬¡èµ°ä¸€æ­¥ã€‚
- å¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆä¸€å®šä¼šç›¸é‡ã€‚ (å¹¶ä¸”ä¸€å®šåœ¨ä¸¤ç¯å†…ç›¸é‡, å³æœ‰é™æ—¶é—´å†…ç›¸é‡)
- ç›¸é‡å, å¿«æŒ‡é’ˆå›åˆ°å¤´èŠ‚ç‚¹, æ…¢æŒ‡é’ˆåœ¨åŸä½ç½®, ç„¶åä¸¤è€…åŒæ—¶ç§»åŠ¨, å¹¶ä¸”éƒ½æ˜¯ä¸€æ¬¡ä¸€æ­¥ã€‚
- ä¸¤ä¸ªæŒ‡é’ˆå†æ¬¡ç›¸é‡æ—¶, æ‰€åœ¨çš„èŠ‚ç‚¹å°±æ˜¯ç¬¬ä¸€ä¸ªç›¸äº¤èŠ‚ç‚¹(å…¥ç¯èŠ‚ç‚¹)

ã€è€å¸ˆä»£ç ã€‘:
```java
public static Node getLoopNode(Node head) {
    if (head == null || head.next == null || head.next.next == null) {
        return null;
    }
    Node n1 = head.next;  // æ…¢æŒ‡é’ˆ
    Node n2 = head.next.next; // å¿«æŒ‡é’ˆ
    while (n1 != n2) {
        if (n2.next == null || n2.next.next == null) {
            return null;
        }
        n2 = n2.next.next;
        n1 = n1.next;
    }
    n2 = head;
    while (n1 != n2) {
        n1 = n1.next;
        n2 = n2.next;
    }
    return n1;
}
```

#### åˆ¤æ–­é“¾è¡¨ç›¸äº¤

ã€æ³¨æ„ã€‘: ä¸¤æ¡é“¾è¡¨ç›¸äº¤å, ä¸€å®šä¼š"ä¸€èµ·èµ°", ä¸å¯èƒ½åˆ†å‰ã€‚ å› ä¸ºå•é“¾è¡¨èŠ‚ç‚¹åªæœ‰ä¸€ä¸ª next èŠ‚ç‚¹ã€‚

ä¸¤æ¡é“¾è¡¨ä¸‰ç§æƒ…å†µ:
- ä¸¤ä¸ªé“¾è¡¨éƒ½æ˜¯æ— ç¯é“¾è¡¨ã€‚ æ— ç¯é“¾è¡¨ç›¸äº¤, å°±ç›¸å½“äºä¸¤æ¡çº¿ç›¸äº¤, ä½†ç”±äºé“¾è¡¨åªæœ‰ä¸€ä¸ª next èŠ‚ç‚¹, æ‰€ä»¥ç›¸äº¤åä¸€å®šæ˜¯ `Y` æƒ…å†µ, è€Œä¸ä¼šå‡ºç° `X` æƒ…å†µã€‚
- ä¸€æ¡æœ‰ç¯, ä¸€æ¡æ— ç¯ã€‚ è¿™ç§æƒ…å†µä¸å¯èƒ½ç›¸äº¤ã€‚ å‡è®¾æ— ç¯é“¾è¡¨å’Œæœ‰ç¯é“¾è¡¨ç›¸äº¤, ç”±äºä¸¤ä¸ªé“¾è¡¨ç›¸äº¤åä¸€å®šä¼šåœ¨ä¸€æ¡çº¿ä¸Š, æ‰€ä»¥æ— ç¯é“¾è¡¨å°±ä¸€å®šä¼šæœ‰ç¯, è¿™ä¸å‡è®¾ä¸ç¬¦, æ•…å‡è®¾ä¸æˆç«‹ã€‚
- ä¸¤æ¡é“¾è¡¨éƒ½æœ‰ç¯ã€‚ ä¸¤æ¡æˆç¯é“¾è¡¨ç›¸äº¤, ä»–ä»¬çš„ç¯ä¸€å®šæ˜¯åŒä¸€ä¸ªã€‚ è¿™ä¸ªç¯, è¦ä¹ˆæ˜¯åœ¨ç›¸äº¤åå½¢æˆçš„, è¦ä¹ˆæ˜¯åœ¨ç›¸äº¤æˆå½¢æˆçš„ã€‚ å¦‚ä¸‹æ‰€ç¤º

```
ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€
ã€€ï¼¼ã€€ã€€ã€€ã€€ã€€ï¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ç¯çš„æ–¹å‘ä¸é‡è¦ï¼Œè°äº¤è°éƒ½ä¸€æ ·ã€€
ã€€ã€€ã€€ï¼¼ã€€ï¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€æ­¤æ—¶ç¯ç‚¹å°±æ˜¯äº¤ç‚¹ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€
ã€€ã€€ã€€ã€€ï½œã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï¼¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï¼ã€€ã€€
ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€
ã€€ã€€ã€€ã€€ï½œã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï¼¼ã€€ï¼ã€€ï¼¼ã€€ï¼ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ï¼ã€€ï¼¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï½œã€€ã€€ã€€ï½œã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ï¼¼ã€€ï¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï¼¼ã€€ï¼ã€€ã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€
```

ã€ä¸¤æ¡ä¸æˆç¯é“¾è¡¨ç›¸äº¤æ—¶çš„äº¤ç‚¹æ±‚å–ã€‘:
- åˆ¤æ–­å°¾èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ, å¦‚æœä¸ç›¸åŒåˆ™ä¸€å®šä¸ç›¸äº¤ã€‚
- è®¡ç®—ä¸¤æ¡é“¾è¡¨çš„é•¿åº¦å·® d
- è®©é•¿çš„é“¾è¡¨ä»å¤´èŠ‚ç‚¹å…ˆèµ° d ä¸ªèŠ‚ç‚¹
- ç„¶åè®©ä¸¤ä¸ªé“¾è¡¨åŒæ—¶èµ°ä¸‹å», ä»–ä»¬è¿Ÿæ—©ä¼šç›¸é‡ã€‚

ã€ä¸¤æ¡æˆç¯é“¾è¡¨ç›¸äº¤æ—¶çš„äº¤ç‚¹æ±‚å–ã€‘:
- åˆ¤æ–­ä¸¤æ¡é“¾è¡¨çš„æˆç¯ç‚¹æ˜¯å¦ç›¸åŒ, å¦‚æœç›¸åŒè¯´æ˜ä»–ä»¬æ˜¯ç›¸äº¤åæ‰æˆç¯çš„ã€‚ å³äº¤ç‚¹ä¸€ç‚¹æ˜¯åœ¨æˆç¯å‰, æ•…ç›´æ¥ä½¿ç”¨ã€ä¸¤æ¡ä¸æˆç¯é“¾è¡¨ç›¸äº¤æ—¶çš„äº¤ç‚¹æ±‚å–ã€‘æ–¹æ³•æ±‚å–å³å¯
- æˆç¯ç‚¹ä¸åŒ, åˆ™ä¸¤æ¡é“¾è¡¨å¯èƒ½ç›¸äº¤ä¹Ÿå¯èƒ½ä¸ç›¸äº¤ã€‚
    - å¦‚æœç›¸äº¤, åˆ™è¯´æ˜æœ‰ä¸€æ¡é“¾è¡¨å…ˆæˆç¯, ç„¶åå¦ä¸€æ¡é“¾è¡¨ç›´æ¥æ’å…¥åˆ°ç¯åœˆä¸Šçš„ä¸€ä¸ªèŠ‚ç‚¹, æ¢å¥è¯è¯´, æ’å…¥çš„è¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯è¿™æ¡é“¾è¡¨çš„æˆç¯ç‚¹, åŒæ—¶ä¹Ÿæ˜¯ä»–ä»¬çš„äº¤ç‚¹ã€‚
    - å¦‚æœä¸ç›¸äº¤, åˆ™ä¸€å®šæ— æ³•å†ç¯åœˆä¸Šæ‰¾åˆ°å¦ä¸€æ¡é“¾è¡¨çš„æˆç¯ç‚¹ã€‚
    - æ•…, åªéœ€è¦åœ¨ä¸€æ¡é“¾è¡¨çš„ç¯åœˆä¸Šç»•ä¸€åœˆ, çœ‹çœ‹æ˜¯å¦æœ‰å¦ä¸€æ¡é“¾è¡¨çš„æˆç¯ç‚¹, å¦‚æœæœ‰, è¯¥ç¯ç‚¹å°±æ˜¯äº¤ç‚¹ã€‚ å¦‚æœé¥¶äº†ä¸€åœˆè¿˜æ²¡æ‰¾åˆ°, è¯´æ˜ä¸ç›¸äº¤ã€‚


ã€è€å¸ˆä»£ç ã€‘:
```java

public static  Node getIntersectNode (Node head1, Node head2) {
    if (head1 == null || head2 == null) {
        return null;
    }
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    if (loop1 == null && loop2 == null) {
        return noLoop(head1, head2);
    }
    if (loop1 != null && loop2 != null) {
        return bothLoop(head1, loop1, head2, loop2);
    }
    return null;
}

public static Node noLoop(Node head1, Node head2) {
    if (head1 == null || head2 == null) {
        return null;
    }
    Node cur1 = head1;
    Node cur2 = head2;
    int n = 0;
    while (cur1.next != null) {
        n++;
        cur1 = cur1.next;
    }
    while (cur2.next != null) {
        n--;
        cur2 = cur2.next;
    }
    if (cur1 != cur2) { // å°¾èŠ‚ç‚¹ä¸åŒ, ä¸€å®šä¸ç›¸äº¤
        return null;
    }
    cur1 = n > 0 ? head1 : head2 ; // è°é•¿, è°çš„å¤´å˜æˆ cur1
    cur2 = cur1 == head1? : head2 : head1; // è°çŸ­, è°çš„å¤´å˜æˆ cur2
    n = Math.abs(n); // ä¸¤æ¡é“¾è¡¨çš„å·®å€¼
    // å…ˆè®©é•¿é“¾è¡¨èµ°å®Œå·®å€¼çš„é•¿åº¦
    while (n != 0) {
        n--;
        cur1 = cur1.next;
    }
    // ç„¶åä¸¤ä¸ªé“¾è¡¨ä¸€èµ·èµ°, ç›¸é‡æ—¶å°±æ˜¯ç¬¬ä¸€ä¸ªäº¤å‰çš„èŠ‚ç‚¹
    while (cur1 != cur2) {
        cur1 = cur1.next;
        cur2 = cur2.next;
    }
    return cur1;
}

public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
    Node cur1 = null;
    Node cur2 = null;
    if (loop1 == loop2) {
        // è·Ÿåˆ¤æ–­ noLoop ç±»ä¼¼, ä½†åŒºåˆ«åœ¨äº noLoop åˆ¤æ–­çš„æ˜¯å°¾å·´æ˜¯ None, è€Œè¿™é‡Œåˆ¤æ–­çš„æ˜¯ loop1, loop2
        cur1 = head1;
        cur2 = head2;
        int n = 0;
        while (cur1 != loop1) {
            n++;
            cur1 = cur1.next;
        }
        while (cur2 != loop2) {
            n--;
            cur2 = cur2.next;
        }
        cur1 = n > 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        while (n != 0) {
            n--;
            cur1 = cur1.next;
        }
        while (cur1 != cur2) {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    } else {
        cur1 = loop1.next;
        while (cur1 != loop1) {
            if (cur1 == loop2) {
                return loop1; // è¿”å› loop1 æˆ– loop2 éƒ½è¡Œ, è¿™ä¸¤ä¸ªéƒ½å«åšç¬¬ä¸€ä¸ªç›¸äº¤çš„èŠ‚ç‚¹
            }
            cur1 = cur1.next;
        }
        // cur1 è½¬å®Œä¸€åœˆåéƒ½æ²¡é‡åˆ° loop2, è¯´æ˜ä¸¤ä¸ªç¯æ²¡æœ‰ç›¸äº¤
        return null;
    }
}
```
