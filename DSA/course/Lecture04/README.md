## ğŸ• æ€»ç»“æ’åº(æ—¶é—´å¤æ‚åº¦, ç©ºé—´å¤æ‚åº¦, ç¨³å®šæ€§)

ä¸‹é¢æŒ‡çš„éƒ½æ˜¯åŸºäºæ•°ç»„ç»“æ„çš„æ’åºã€‚

| æ’åºç®—æ³•(å…¸å‹)   | æ—¶é—´å¤æ‚åº¦(é€šå¸¸æƒ…å†µ) | (é¢å¤–)ç©ºé—´å¤æ‚åº¦(é€šå¸¸æƒ…å†µ) | ç¨³å®šæ€§(é€šå¸¸æƒ…å†µ) |
|---------------|----------------------|----------------------------|----------------|
| é€‰æ‹©æ’åº         | $O(N^2)$             | $O(1)$                     | âŒä¸ç¨³å®š          |
| å†’æ³¡æ’åº         | $O(N^2)$             | $O(1)$                     | âœ”ï¸ç¨³å®š           |
| æ’å…¥æ’åº         | $O(N^2)$             | $O(1)$                     | âœ”ï¸ç¨³å®š           |
| **å½’å¹¶æ’åº**     | $O(N * logN)$        | $O(N)$                     | âœ”ï¸ç¨³å®š           |
| **éšæœºå¿«é€Ÿæ’åº** | $O(N * logN)$        | $O(logN)$                  | âŒä¸ç¨³å®š          |
| **å †æ’åº**       | $O(N * logN)$        | $O(1)$                     | âŒä¸ç¨³å®š          |
| è®¡æ•°æ’åº         | $O(N)$               | $O(N)$                     | âœ”ï¸ç¨³å®š           |
| åŸºæ•°æ’åº         | $O(N)$               | $O(N)$                     | âœ”ï¸ç¨³å®š           |

### ç¨³å®šæ€§

ç¨³å®šå°±æ˜¯: å½“å­˜åœ¨ç›¸ç­‰å…ƒç´ æ—¶, æ’åºåå®ƒä»¬çš„ç›¸å¯¹é¡ºåºä¸å˜ã€‚

- é€‰æ‹©æ’åº: æ¯æ¬¡é€‰æ‹©æœ€å°çš„æ•°ä¸ç¬¬ä¸€ä¸ªæ•°äº¤æ¢ã€‚
    - æ’åºåä¸ç¨³å®šğŸŒ°:
        - [ $3_a$, $3_b$, 1 ]
        - [ 1, $3_b$, $3_a$ ] ç¬¬ä¸€è½®éå†æ—¶, é€‰åˆ°æœ€å°å€¼ 1, å°†å®ƒä¸ç¬¬ä¸€ä¸ªæ•°äº¤æ¢
        - å¾ˆæ˜æ˜¾, æ’åºåçš„ $3_b$ å’Œ $3_a$ ä½ç½®äº’æ¢äº†ã€‚

- å†’æ³¡æ’åº: å¦‚æœå·¦å€¼ > å³å€¼, å°±äº¤æ¢ã€‚
    - æ’åºåç¨³å®šğŸŒ°:
        - [ $3_a$, $3_b$, 1 ]
        - [ $3_a$, 1, $3_b$ ]
        - [ 1, $3_a$, $3_b$ ]
    - æ³¨æ„âš ï¸, å¦‚æœå†’æ³¡æ’åºçš„å®ç°å†™æˆå·¦å€¼ >= å³å€¼æ—¶äº¤æ¢, åˆ™å†’æ³¡æ’åºä¼šå˜æˆä¸ç¨³å®šï¼š
        - [ $3_a$, $3_b$ ]
        - [ $3_b$, $3_a$ ] å› ä¸ºæ­¤æ—¶å·¦å€¼ == å³å€¼, æ‰€ä»¥è¿˜ä¼šç»§ç»­äº¤æ¢, æ­¤æ—¶å°±ä¼šå¯¼è‡´ä¸ç¨³å®š

- æ’å…¥æ’åº: å½“å·¦å€¼ >= å³å€¼æ—¶, åœæ­¢æ’å…¥(äº¤æ¢)ã€‚
    - æ’åºåç¨³å®šğŸŒ°:
        - [ $3_a$, $3_b$, 1 ]
        - [ $3_a$, 1, $3_b$ ]
        - [ 1, $3_a$, $3_b$ ]
    - åŒæ ·æ³¨æ„âš ï¸, å¦‚æœå½“ä¸¤ä¸ªå€¼ç›¸ç­‰æ—¶, è¿˜è¦ç»§ç»­æ’å…¥, åˆ™ä¼šå˜æˆä¸ç¨³å®šï¼š
        - [ $3_a$, 1, $3_b$ ]
        - [ 1, $3_a$, $3_b$ ] æ’å¥½ 1
        - [ 1, $3_a$, $3_b$ ] æ’å¥½ $3_a$
        - [ 1, $3_b$, $3_a$ ] æ’å¥½ $3_b$

- å½’å¹¶æ’åº: å…ˆäºŒåˆ†åä¾æ¬¡æ’åº, ç„¶ååˆå¹¶ã€‚ åˆå¹¶è¿‡ç¨‹ä¸­è‹¥ä¸¤ä¸ªæ•°ç›¸ç­‰, å…ˆåˆå¹¶å·¦è¾¹
    - æ’åºåç¨³å®šğŸŒ°:
        - merge [ 1, $3_a$ ]  [ $3_b$ ]
        - merge result: [ 1 ]
        - merge result: [ 1, $3_a$ ]
        - merge result: [ 1, $3_a$, $3_b$ ]
    - åŒæ ·æ³¨æ„âš ï¸, å¦‚æœå…ˆåˆå¹¶å³è¾¹, åˆ™ä¼šä¸ç¨³å®šã€‚ è€Œå‰é¢ä»‹ç»è¿‡çš„ "å°å’Œé—®é¢˜", å°±æ˜¯å…ˆåˆå¹¶å³è¾¹çš„, æ‰€ä»¥é‚£æ—¶çš„å½’å¹¶æ˜¯ä¸ç¨³å®šçš„
        - merge [ 1, $3_a$ ]  [ $3_b$ ]
        - merge result: [ 1 ]
        - merge result: [ 1, $3_b$ ]
        - merge result: [ 1, $3_b$, $3_a$ ]

- å¿«é€Ÿæ’åº: ä¸æ–­çš„éšæœºé€‰å– pivot(åˆ’åˆ†å€¼), ç„¶åæ‰§è¡Œ partitionã€‚partition æ ¸å¿ƒ: å°†æ•°å€¼åˆ’åˆ†è¿›å¯¹åº”åŒºåŸŸã€‚ æ¯”å¦‚, å°† < pivot çš„å€¼åˆ’åˆ†è¿› "< åŒº", å…·ä½“åšæ³•æ˜¯å°†è¯¥å€¼åŸŸ "< åŒº" è¾¹ç•Œäº¤æ¢, ç„¶åæ‰©å¤§è¾¹ç•Œã€‚
    - æ’åºåä¸ç¨³å®šğŸŒ°:
        - [ $3_a$, $3_b$, 1 ], é€‰å–çš„ pivot æ˜¯ 2
        - [ 1, $3_b$, $3_a$ ], è¯†åˆ«åˆ° 1 æ—¶, å°†å®ƒä¸ "< åŒº" çš„è¾¹ç•Œ+1 å€¼äº¤æ¢, æ•… $3_a$ è·¨è¿‡äº† $3_b$
    - ä¸ç®¡æ˜¯äºŒé¡¹åˆ’åˆ†è¿˜æ˜¯ä¸‰é¡¹åˆ’åˆ†, ç»“æœéƒ½æ˜¯ä¸ç¨³å®šçš„ã€‚


- å †æ’åº: åˆ©ç”¨å †çš„ç‰¹æ€§(å¯ä»¥æ˜¯å¤§æ ¹å †æˆ–å°æ ¹å †)è¿›è¡Œæ’åº
    - åœ¨æ„é€ å †çš„è¿‡ç¨‹ä¸­å°±å·²ç»æ‰“ä¹±äº†é¡ºåº, ä¸¾ä¸ªå°æ ¹å †æ‰“ä¹±ğŸŒ°:
        - åŸæ•°ç»„: [ $3_a$, $3_b$, 1 ]
        - å¯¹ 1 è¿›è¡Œ heap insert (æˆ–è€…å¯¹ $3_a$ è¿›è¡Œ heapify) çš„è¿‡ç¨‹ä¸­, å°†ä¼šäº¤æ¢ 1 å’Œ $3_a$ çš„ä½ç½®, ç»“æœå¦‚ä¸‹
        - å°æ ¹å †: [ 1, $3_b$, $3_a$ ]

- è®¡æ•°æ’åº, åŸºæ•°æ’åº, ä»–ä»¬çš„ç®—æ³•æ€è·¯æœ¬èº«å°±ä¸æ˜¯åŸºäºæ¯”è¾ƒçš„, ä»–ä»¬æ˜¯åˆ©ç”¨ "æ¡¶" çš„ç»“æ„æ¥å®ç°æ’åºçš„, æ‰€ä»¥åªè¦ç¡®ä¿ "å…¥æ¡¶" å’Œ "å‡ºæ¡¶" çš„è¿‡ç¨‹ä¸­å…ƒç´ çš„ç›¸å¯¹é¡ºåºä¸å˜, é‚£ä¹ˆä»–ä»¬å°±æ˜¯ç¨³å®šçš„

### æ€»ç»“

å‰é¢çš„å‡ ç§æ’åº, å¯ä»¥åˆ†ä¸ºä¸‰å¤§ç±», é€‰æ‹©å†’æ³¡æ’å…¥ä½œä¸ºä¸€ç±», å½’å¹¶å¿«æ’å †ä½œä¸ºä¸€ç±», è®¡æ•°åŸºæ•°ä½œä¸ºä¸€ç±»ã€‚
å¯¹äºè®¡æ•°å’ŒåŸºæ•°æ’åº, åªé€‚ç”¨äºç‰¹å®šæƒ…å†µã€‚
é€‰æ‹©å†’æ³¡æ’å…¥æ’åº, å¯ä»¥ä½œä¸ºç®€å•æ’åºç®—æ³•çš„å­¦ä¹ , åªé€‚ç”¨ç®€å•æ•°æ®ã€‚
å½’å¹¶å¿«æ’å †æ’åº, é€‚ç”¨èŒƒå›´æœ€å¹¿ã€‚

å½’å¹¶, å¿«æ’, å † å¦‚ä½•é€‰å–?
- ä¸€èˆ¬éƒ½æ˜¯é€‰æ‹© **éšæœºå¿«æ’** è¿›è¡Œæ’åºã€‚ è™½ç„¶å¿«æ’å’Œå †çš„æ—¶é—´å¤æ‚åº¦ç›¸åŒ, ä½†å®è·µè¿‡ç¨‹ä¸­å‘ç°å¿«æ’çš„å¸¸æ•°æ—¶é—´æ›´çŸ­ã€‚
- å½“æœ‰ç¨³å®šæ€§éœ€æ±‚æ—¶, é€‰æ‹©å½’å¹¶æ’åº
- å½“è¦å‹æ¦¨ç©ºé—´æ—¶, é€‰æ‹©å †æ’åº

æ’åºç®—æ³•å¸¸è§çš„å‘
- å½’å¹¶æ’åºçš„é¢å¤–ç©ºé—´å¤æ‚åº¦å¯ä»¥å˜æˆ O(1)ã€‚â€”â€” éå¸¸éš¾å®ç°, ä¸éœ€è¦æŒæ¡ã€‚æœ‰å…´è¶£å¯ä»¥æœç´¢"å½’å¹¶æ’åº å†…éƒ¨ç¼“å­˜æ³•"ã€‚ è€Œä¸”è™½ç„¶ç©ºé—´å¤æ‚åº¦é™äº†, ä½†åŒæ—¶å®ƒä¹Ÿå˜å¾—ä¸ç¨³å®šäº†, é‚£ä¸ºä»€ä¹ˆä¸ç”¨å †æ’åºå‘¢?
- åŸåœ°å½’å¹¶æ’åºå¯ä»¥å®ç°ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚â€”â€” è™½ç„¶ç©ºé—´å¤æ‚åº¦é™ä½äº†, ä½†å®ƒçš„æ—¶é—´å¤æ‚åº¦å˜æˆäº† O(N^2), é‚£ä¸ºä»€ä¹ˆä¸ç”¨ç®€å•æ’åºå‘¢
- å¿«é€Ÿæ’åºå¯ä»¥åšåˆ°ç¨³å®šã€‚ â€”â€” éš¾ã€‚ è€Œä¸”è™½ç„¶åšåˆ°äº†ç¨³å®šæ€§, ä½†ç©ºé—´å¤æ‚åº¦ä¼šå˜æˆ O(N), é‚£ä¸ºä»€ä¹ˆä¸ç”¨å½’å¹¶æ’åºå‘¢? æœ‰å…´è¶£å¯ä»¥æœç´¢ "01 stable sort"ã€‚
- é¢è¯•é¢˜: è¦æ±‚å¥‡æ•°æ”¾åœ¨æ•°ç»„å·¦è¾¹, å¶æ•°æ”¾åœ¨æ•°ç»„å³è¾¹, åŒæ—¶ç›¸å¯¹æ¬¡åºä¸å˜, å¹¶ä¸”æ—¶é—´å¤æ‚åº¦ä¸º O(N), ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚
    - å›ç­”: ç»å…¸çš„å¿«æ’åšä¸åˆ°ç¨³å®šæ€§, è€Œç»å…¸å¿«æ’çš„ partition åˆæ˜¯ 01 æ ‡å‡†çš„, å®ƒå’Œè¿™ä¸ªå¥‡å¶é—®é¢˜å…¶å®æ˜¯ä¸€ç§è°ƒæ•´ç­–ç•¥, å¿«æ’åšä¸åˆ°, æ‰€ä»¥æˆ‘ä¹Ÿä¸çŸ¥é“æ€ä¹ˆåšã€‚ ç„¶åæŠŠé—®é¢˜åæŠ›ç»™é¢è¯•å®˜ã€‚
    - partition è¿‡ç¨‹, èƒ½å¤Ÿå°† "â‰¤ pivot" çš„æ”¾å·¦è¾¹, "> pivot" çš„æ”¾å³è¾¹, è¿™å…¶å®å°±æ˜¯ "01æ ‡å‡†"ã€‚ å®ƒèƒ½åšåˆ°æ—¶é—´å¤æ‚åº¦ O(N), ç©ºé—´å¤æ‚åº¦ O(1), ä½†å®ƒåšä¸åˆ°ç¨³å®šã€‚ æ‰€ä»¥è¿™é“é¢è¯•é¢˜ç›®å‰æ˜¯æ— è§£çš„ã€‚

### å·¥ç¨‹ä¸Šå¯¹æ’åºçš„æ”¹è¿›

- å……åˆ†åˆ©ç”¨ O(N*logN) å’Œ O(N^2) å„è‡ªçš„ä¼˜åŠ¿ã€‚
æ¯”å¦‚åœ¨å¤§æ•°æ®é‡çš„æ—¶å€™ä½¿ç”¨å¿«æ’, åœ¨å°æ•°æ®é‡çš„æ—¶å€™ä½¿ç”¨æ’å…¥ã€‚ æ‰€ä»¥åœ¨å¿«æ’çš„ä»£ç ä¸Š, ç»å¸¸ä¼šçœ‹åˆ°åœ¨æ’åºå‰, å…ˆç”¨ if åˆ¤æ–­ä¸€ä¸‹å¾…æ’åºçš„æ•°æ®, å¦‚æœå°äºä¸€å®š 60 ä¸ª, åˆ™ä½¿ç”¨çš„æ˜¯æ’å…¥æ’åºã€‚ã€€

- ç¨³å®šæ€§é—®é¢˜ã€‚
å¯¹äºåŸºæœ¬æ•°æ®, ä¸éœ€è¦è€ƒè™‘ç¨³å®šæ€§é—®é¢˜ã€‚ æ¯”å¦‚ç³»ç»Ÿæä¾›çš„æ’åºé»‘ç›’, å½“æ•°æ®æ˜¯åŸºæœ¬ç±»å‹æ—¶, å®ƒä¼šä½¿ç”¨å¿«æ’ã€‚ ä½†æ•°æ®æ˜¯å¯¹è±¡æ—¶, å®ƒä¼šä½¿ç”¨å½’å¹¶ã€‚


## ğŸ• ç®€å•äº†è§£å“ˆå¸Œè¡¨

å“ˆå¸Œè¡¨æœ‰ä¸¤ç§, Map å’Œ Set, è¿™ä¸¤ç§æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ã€‚ Map æ˜¯ key-value çš„å½¢å¼, Set æ˜¯åªæœ‰ key çš„å½¢å¼ã€‚

å“ˆå¸Œè¡¨çš„å¢åˆ æ”¹æŸ¥æ“ä½œéƒ½æ˜¯ O(1) çº§åˆ«çš„ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯, å“ˆå¸Œè¡¨çš„å¸¸æ•°æ—¶é—´æ˜¯æ¯”è¾ƒå¤§çš„, å®ƒç›¸æ¯”æ•°ç»„å¯»å€è‚¯å®šæ˜¯æ¯”è¾ƒæ…¢ä¸€ç‚¹çš„ã€‚

æ³¨æ„ä¸€ä¸ªæ¦‚å¿µï¼š å€¼ä¼ é€’è¿˜æ˜¯å¼•ç”¨ä¼ é€’ã€‚ é€šå¸¸æƒ…å†µæ˜¯, å“ˆå¸Œè¡¨çš„è§„åˆ™æ˜¯:
- å½“ key ç±»å‹æ˜¯åŸºç¡€ç±»å‹æ—¶, å“ˆå¸Œè¡¨å†…éƒ¨æ˜¯å€¼ä¼ é€’çš„; æ­¤æ—¶å“ˆå¸Œè¡¨å†…éƒ¨ä¼šå¼€è¾Ÿä¸€å—ç©ºé—´å­˜å‚¨å…·ä½“çš„å€¼, è¿™å—ç©ºé—´çš„å¤§å°ç”±å…·ä½“çš„å€¼å†³å®šã€‚
- å½“ key ç±»å‹æ˜¯å¤æ‚ç±»å‹æ—¶, å“ˆå¸Œè¡¨å†…éƒ¨æ˜¯å¼•ç”¨ä¼ é€’æ—¶; æ­¤æ—¶å“ˆå¸Œè¡¨å†…éƒ¨åªä¼šå­˜å‚¨å¼•ç”¨, ä¸ä¼šé‡æ–°æ‹·è´ä¸€ä»½æ•°æ®ã€‚ å¼•ç”¨æ‰€å ç”¨çš„ç©ºé—´çš„å¤§å°æ˜¯å›ºå®šçš„ã€‚

> java ä¸­çš„å“ˆå¸Œè¡¨æ˜¯ HashSet, HashMap ç»“æ„
> C++ ä¸­çš„å“ˆå¸Œè¡¨æ˜¯ UnorderedSet, UnorderedMap ç»“æ„


## ğŸ• ç®€å•äº†è§£æœ‰åºè¡¨

æœ‰åºè¡¨å’Œå“ˆå¸Œè¡¨ç±»ä¼¼, ä¹Ÿæœ‰ Map å’Œ Set ä¸¤ç§ã€‚
åªä¸è¿‡æœ‰åºè¡¨å®ç°äº†å¯¹ key è¿›è¡Œæ’åºã€‚ æ‰€ä»¥å¯ä»¥æŒ‰ç…§ç‰¹å®šé¡ºåºè·å–æœ‰åºè¡¨ä¸­çš„ key-valueã€‚
æ³¨æ„, å¦‚æœä¼ é€’ç»™æœ‰åºè¡¨çš„ key æ— æ³•ç›´æ¥æ¯”è¾ƒ, åˆ™éœ€è¦ä¼ é€’æ¯”è¾ƒå™¨ã€‚

æœ‰åºè¡¨çš„å¢åˆ æ”¹æŸ¥æ“ä½œéƒ½æ˜¯ O(logN) çº§åˆ«çš„ã€‚

çº¢é»‘æ ‘, AVL æ ‘, size-balance-tree å’Œè·³è¡¨ç­‰éƒ½å±äºæœ‰åºè¡¨ç»“æ„ã€‚ åªæ˜¯åº•å±‚å…·ä½“å®ç°ä¸åŒã€‚

> java ä¸­çš„æœ‰åºè¡¨æ˜¯ TreeSet, TreeMap ç»“æ„
> C++ ä¸­çš„æœ‰åºè¡¨æ˜¯ OrderedSet, OrderedMap ç»“æ„

## ğŸ• é“¾è¡¨

é“¾è¡¨åˆ†ä¸ºå•é“¾è¡¨å’ŒåŒé“¾è¡¨:
- å•é“¾è¡¨: å•å‘è¿æ¥
- åŒé“¾è¡¨: åŒå‘è¿æ¥

### å°ç»ƒä¹  - åè½¬é“¾è¡¨

ã€é¢˜ç›®ã€‘: åˆ†åˆ«å®ç°åè½¬å•é“¾è¡¨å’Œåè½¬åŒé“¾è¡¨çš„å‡½æ•°ã€‚
ã€è¦æ±‚ã€‘: å¦‚æœé“¾è¡¨é•¿åº¦ä¸º N, è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚

ã€âš ï¸é‡ç‚¹ã€‘ï¼š å½“ä½ æ–­æ‰æŸä¸ªé“¾æ¡æ—¶, ä½ è¦æ¸…æ¥šæ˜¯å¦éœ€è¦ä½¿ç”¨åˆ°æ–­å¼€ä¹‹å‰æ‰€æŒ‡å‘çš„èŠ‚ç‚¹! å¦‚æœéœ€è¦, é‚£ä¹ˆä¸€å®šè¦å…ˆå°†è¯¥èŠ‚ç‚¹å­˜å‚¨èµ·æ¥ï¼

ã€æˆ‘çš„ä»£ç ã€‘ï¼š

```py
def reversed_linked_list(head, is_double=False):
    # åˆ¤æ–­è¾¹ç•Œæ¡ä»¶
    if head is None or head.next is None:
        return head

    # åˆå§‹å€¼
    pr = None
    p = head
    pn = p.next

    while True:
        p.next = pr # åè½¬
        if is_double:
            p.prev = pn # åè½¬åŒé“¾è¡¨åªå¤šäº†è¿™ä¸€æ­¥

        # ç»“æŸåˆ¤æ–­
        if pn is None:
            break

        # æ›´æ–°
        pr = p
        p = pn
        pn = p.next

    return p
```


### å°ç»ƒä¹  - æ‰“å°ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„å…¬å…±éƒ¨åˆ†

ã€é¢˜ç›®ã€‘: ç»™å®šä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„å¤´æŒ‡é’ˆ head1 å’Œ head2, æ‰“å°ä¸¤ä¸ªé“¾è¡¨çš„å…¬å…±éƒ¨åˆ†ã€‚
ã€è¦æ±‚ã€‘: å¦‚æœä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ä¹‹å’Œä¸º N, æ—¶é—´å¤æ‚åº¦è¦æ±‚ä¸º O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦è¦æ±‚ä¸º O(1)ã€‚

ã€ç®—æ³•æ€è·¯ã€‘: ä¸¤ä¸ªæŒ‡é’ˆ, è°å°è°ç§»åŠ¨ã€‚ ç›¸åŒæ—¶æ‰“å°å¹¶ä¸€èµ·ç§»åŠ¨ã€‚ ç›´åˆ°æŸä¸€æŒ‡é’ˆè¶Šç•Œã€‚

ã€æˆ‘çš„ä»£ç ã€‘:
```py
def linked_list_common(head1, head2):
    common = []
    while head1 is not None and head2 is not None:
        if head1.data < head2.data:
            head1 = head1.next
        elif head1.data > head2.data:
            head2 = head2.next
        else:
            common.append(head1.data)
            head1 = head1.next
            head2 = head2.next
    return common
```

### é¢è¯•æ—¶é“¾è¡¨è§£é¢˜æ–¹æ³•è®º

ç¬”è¯•å’Œé¢è¯•è¦æ±‚ä¸ä¸€æ ·ã€‚
- ç¬”è¯•: èƒ½è¿‡å°±è¡Œ, æ²¡äººçœ‹ä½ ä»£ç ã€‚ æ‰€ä»¥ä¸ç”¨å¤ªåœ¨ä¹ç©ºé—´å¤æ‚åº¦, ä¸€åˆ‡ä¸ºäº†æ—¶é—´å¤æ‚åº¦ã€‚
- é¢è¯•: æ—¶é—´å¤æ‚åº¦ä»ç„¶æ˜¯ç¬¬ä¸€ä½, ä½†æ˜¯ç©ºé—´å¤æ‚åº¦ä¸€å®šè¦çœã€‚ å› ä¸ºæ­¤æ—¶çœ‹ä½ çš„ä¸æ˜¯æœºå™¨, æ˜¯é¢è¯•å®˜ã€‚

ã€æŠ€å·§ã€‘:
- é¢å¤–æ•°æ®ç»“æ„è®°å½•(å“ˆå¸Œè¡¨ç­‰)
- å¿«æ…¢æŒ‡é’ˆã€‚ æ¯”å¦‚ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸€æ­¥, ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸¤æ­¥ã€‚

### ç»ƒä¹  - åˆ¤æ–­å•é“¾è¡¨å›æ–‡

ã€åšæ³•1(ç¬”è¯•)ã€‘: å…ˆéå†ä¸€éé“¾è¡¨, å¹¶æŠŠå€¼ä¾æ¬¡æ”¾å…¥æ ˆä¸­ã€‚ å†éå†ä¸€éé“¾è¡¨, æ­¤æ—¶æ¯æ¬¡éå†éƒ½å°†æ ˆçš„å†…å®¹å¼¹å‡º, ç„¶åæ¯”è¾ƒæ˜¯å¦ç›¸ç­‰ã€‚ ç›´åˆ°ä¸ç›¸ç­‰æˆ–è€…æ ˆä¸ºç©ºã€‚

ã€åšæ³•2(ç¬”è¯•)ã€‘:
åšæ³• 1 ä¸­éå†äº†ä¸¤éé“¾è¡¨, è€Œä¸”æ ˆå ç”¨çš„ç©ºé—´å¤§å°ä¸º Nã€‚
ä½†å®é™…ä¸Š, å½“æˆ‘ä»¬éå†åˆ°é“¾è¡¨ä¸­é—´ä¹‹å, å°±å¯ä»¥å°†æ ˆä¸­çš„å…ƒç´  pop å‡ºæ¥å’Œé“¾è¡¨è¿›è¡Œæ¯”è¾ƒäº†ã€‚
é—®é¢˜åœ¨äº, å¦‚ä½•ç¡®å®šä¸­é—´ä½ç½®? æ–¹æ³•å°±æ˜¯ **å¿«æ…¢æŒ‡é’ˆ**ã€‚
ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸€æ­¥, ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸¤æ­¥ã€‚ å½“å¿«æŒ‡é’ˆåˆ°å¤´æ—¶, å°±è¯´æ˜åˆ°ä¸­é—´é™„è¿‘äº†ã€‚

ã€åšæ³•3(é¢è¯•)ã€‘:ä¸å€ŸåŠ©æ ˆå®ç°:
1. æ‰¾åˆ°ä¸­é—´ä½ç½®
2. ä»ä¸­é—´, å°†åé¢çš„é“¾è¡¨èŠ‚ç‚¹åè½¬ã€‚
3. ä»é“¾è¡¨ä¸¤ç«¯å¾€ä¸­é—´ä¸€ä¸€æ¯”è¾ƒ, å³é“¾è¡¨åœ¨æ¯”è¾ƒçš„è¿‡ç¨‹ä¸­å†æ¬¡å°†é“¾è¡¨åè½¬

ã€æ³¨æ„âš ï¸ã€‘: æ€è·¯éƒ½å¾ˆç®€å•, éœ€è¦æ³¨æ„çš„åªæœ‰é•¿åº¦å¥‡å¶æ•°æƒ…å†µä¸‹, ä¸­ç‚¹çš„é€‰å–ã€‚ æ ¹æ®é¢˜æ„çš„ä¸åŒ, é€‰å–çš„æ–¹å¼ä¹Ÿä¸åŒã€‚

#### è€å¸ˆä»£ç 

```java
// æ–¹æ³•1
public static boolean isPalindrome1(Node head) {
    Stack<Node> stack = new Stack<Node>();
    Node cur = head;
    // å°†é“¾è¡¨æ‰€æœ‰èŠ‚ç‚¹å…¥æ ˆ
    while (cur != null) {
        stack.push(cur);
        cur = cur.next;
    }
    // å†æ¬¡éå†é“¾è¡¨, å¹¶ä»æ ˆä¸­å…ƒç´ ä¸€ä¸€æ¯”è¾ƒ
    while (head != null) {
        if (head.value != stack.pop().value) {
            return false;
        }
        head = head.next;
    }
    return true;
}

// æ–¹æ³•2
public static boolean isPalindrome2(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    Node right = head.next;
    Node cur = head;
    // æ‰¾åˆ°ä¸­ç‚¹ä½ç½®
    while (cur.next != null && nul.next.next != null) {
        right = right.next;
        cur = cur.next.next;
    }
    // ä»ä¸­ç‚¹ä½ç½®å†å¼€å§‹å°†å…ƒç´ å…¥æ ˆ
    Stack<Node> stack = new Stack<Node>();
    while (right != null) {
        stack.push(right);
        right = right.next;
    }
    // å†æ¬¡éå†, ä¸€ä¸€æ¯”è¾ƒ
    while (!stack.isEmpty()) {
        if (head.value != stack.pop().value) {
            return false;
        }
        head = head.next;
    }
}

// æ–¹æ³•3
public static boolean isPalindrome3(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    Node n1 = head;
    Node n2 = head;
    // å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­é—´
    while (n2.next != null && n2.next.next != null) {
        n1 = n1.next;
        n2 = n2.next.next;
    }
    // åè½¬ååŠé“¾è¡¨
    n2 = n1.next;
    n1.next = null;
    Node n3 = null;
    while (n2 != null) {
        n3 = n3.next;
        n2.next = n1;
        n2 = n3;
    }
    // ä»é“¾è¡¨ä¸¤ç«¯å‘ä¸­é—´ä¸€ä¸€æ¯”è¾ƒ
    n3 = n1;
    n2 = head;
    boolean res = true;
    while (n1 != null && n2 != null) {
        if (n1.value != n2.value) {
            res = false;
            break;
        }
        n1 = n1.next;
        n2 = n2.next;
    }
    // å®Œæˆåå†æ¬¡æŠŠååŠé“¾è¡¨åè½¬
    n1 = n3.next;
    n3.next = null;
    while (n1 != null) {
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
    }
}

```

#### æˆ‘çš„ä»£ç 


```py
def is_palindrome_linked_list2(head):
    if head is None:
        return False
    if head.next is None:
        return True
    # åˆ©ç”¨å¿«æ…¢æŒ‡é’ˆ, èµ°åˆ°ä¸­ç‚¹å°±å¼€å§‹å‡ºæ ˆæ¯”è¾ƒ
    slow = head
    quick = head.next
    mid_r = None  # å¶:åå³; å¥‡:ä¸­ç‚¹å³è¾¹
    half_stack = []  # åªä¼šå¡«å……å·¦ä¾§ã€‚ å¶:å¡«ä¸€åŠ; å¥‡:ä¸åŒ…å«ä¸­ç‚¹
    while True:
        half_stack.append(slow.data)
        if quick.next is None:  # å¶
            mid_r = slow.next
            break
        if quick.next.next is None:  # å¥‡
            mid_r = slow.next.next
            break
        slow = slow.next
        quick = quick.next.next
    while mid_r is not None:
        if (mid_r.data != half_stack.pop()):
            return False
        mid_r = mid_r.next
    return True


def is_palindrome_linked_list3(head):
    if head is None:
        return False
    if head.next is None:
        return True
    # ä¸å€ŸåŠ©æ ˆ, è¿‡äº†ä¸­ç‚¹åå°†é“¾è¡¨åè½¬
    # ç„¶åä»é“¾è¡¨ä¸¤ä¾§å¾€å›ä¸€ä¸€æ¯”è¾ƒ, å¾€å›èµ°æ—¶å†æ¬¡åè½¬é“¾è¡¨
    slow = head
    quick = head.next
    mid_r = None
    while True:
        if quick.next is None:
            mid_r = slow.next
            break
        if quick.next.next is None:
            mid_r = slow.next.next
            break
        slow = slow.next
        quick = quick.next.next
    # ä» mid_r èŠ‚ç‚¹å¼€å§‹è¿›è¡Œåè½¬
    pr, p, pn = None, mid_r, mid_r.next
    while True:
        p.next = pr
        if pn is None:
            break
        pr = p
        p = pn
        pn = p.next
    # æ­¤æ—¶çš„ p æ˜¯å³é“¾è¡¨å¤´èŠ‚ç‚¹, mid_r æ˜¯å°¾èŠ‚ç‚¹
    # ç°åœ¨å†æ¬¡åè½¬å³é“¾è¡¨, åœ¨åè½¬çš„è¿‡ç¨‹ä¸­ä¸å·¦é“¾è¡¨ä¸€ä¸€æ¯”è¾ƒ
    left = head
    pr, p, pn = None, p, p.next
    is_palindrome = True
    while True:
        if left.data != p.data:
            is_palindrome = False
        p.next = pr
        if pn is None:
            break
        pr = p
        p = pn
        pn = p.next
        left = left.next
    return is_palindrome
```

### ç»ƒä¹  - å¯¹å•é“¾è¡¨çš„å€¼è¿›è¡Œåˆ’åˆ†

ã€é¢˜ç›®ã€‘: ç»™å®šä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head, èŠ‚ç‚¹çš„å€¼ç±»å‹æ˜¯æ•´å‹, å†ç»™å®šä¸€ä¸ªæ•´æ•° pivotã€‚
å®ç°ä¸€ä¸ªè°ƒæ•´é“¾è¡¨çš„å‡½æ•°, å°†é“¾è¡¨è°ƒæ•´ä¸ºå·¦éƒ¨åˆ†éƒ½æ˜¯å€¼å°äº pivot çš„èŠ‚ç‚¹, ä¸­é—´éƒ¨åˆ†éƒ½æ˜¯å€¼ç­‰äº pivot çš„èŠ‚ç‚¹, å³éƒ¨åˆ†éƒ½æ˜¯å€¼å¤§äº pivot çš„èŠ‚ç‚¹ã€‚
ã€è¿›é˜¶ã€‘: è¦æ±‚å®ç°ç¨³å®šæ€§, åŒæ—¶æ—¶é—´å¤æ‚åº¦ä¸º O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚

ã€åšæ³• 1(ç¬”è¯•)ã€‘: æŠŠå•é“¾è¡¨è½¬æ¢ä¸ºæ•°ç»„, ç„¶ååšå¿«æ’çš„ partitionã€‚ åšå®Œåå†æŠŠæ•°ç»„è½¬æ¢ä¸ºå•é“¾è¡¨

ã€åšæ³• 2(é¢è¯•)ã€‘:
å®šä¹‰ä¸‰ä¸ªåŒºåŸŸçš„ç©ºé“¾è¡¨ã€‚ éå†é“¾è¡¨, å°†æ¯æ¬¡éå†åˆ°çš„èŠ‚ç‚¹æ”¾åˆ°æ­£ç¡®çš„åŒºåŸŸå†…ã€‚ éå†å®Œæˆåå°†ä¸‰ä¸ªåŒºåŸŸçš„é“¾è¡¨è¿æ¥èµ·æ¥å°±å¯ä»¥äº†ã€‚

ç”±äºé“¾è¡¨ä¸­èŠ‚ç‚¹çš„ç§»åŠ¨ä»£ä»·æ˜¯ O(1), æ‰€ä»¥ä»…éœ€æœ‰é™çš„å‡ ä¸ªå˜é‡å°±å®ç°é“¾è¡¨ partitionã€‚

ã€ä»£ç æ€è·¯ã€‘ï¼š
1. å®šä¹‰ 6 ä¸ªå˜é‡, SH è¡¨ç¤º "< åŒº" çš„å¤´èŠ‚ç‚¹, ST è¡¨ç¤º "<" åŒºåŸŸçš„å°¾èŠ‚ç‚¹ã€‚ åŒç†è¿˜æœ‰ "= åŒº" çš„ä¸¤ä¸ªèŠ‚ç‚¹ EH å’Œ ET,   "> åŒº" çš„ä¸¤ä¸ªèŠ‚ç‚¹ BH å’Œ BTã€‚ ä»–ä»¬çš„åˆå§‹å€¼éƒ½æ˜¯ç©ºã€‚
2. éå†é“¾è¡¨
3. å½“èŠ‚ç‚¹ < åˆ’åˆ†å€¼æ—¶, å°†èŠ‚ç‚¹æ”¾åˆ° "< åŒº" çš„é“¾è¡¨ä¸Šã€‚å…·ä½“åšæ³•æ˜¯: ç¬¬ä¸€ä¸ªå°äºåˆ’åˆ†å€¼çš„èŠ‚ç‚¹, å°†å®ƒåŒæ—¶èµ‹å€¼ç»™ SH å’Œ ST, ç„¶å SH å°±ä¸ç”¨å˜äº†ã€‚ åç»­å†é‡åˆ°ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹æ—¶, å°†å®ƒä½œä¸º ST çš„ä¸‹ä¸€èŠ‚ç‚¹, åŒæ—¶ ST å‘ä¸‹ç§»åŠ¨, ä»¥æ­¤ç±»æ¨ã€‚
4. å½“èŠ‚ç‚¹ == åˆ’åˆ†å€¼æˆ–èŠ‚ç‚¹ > åˆ’åˆ†å€¼ æ—¶, éƒ½æ˜¯åŒæ ·çš„åšæ³•ã€‚
5. ç»“æŸæ—¶, å°†ä¸‰æ¡é“¾è¡¨è¿æ¥èµ·æ¥ã€‚ å…·ä½“åšæ³•:
    - åœ¨ ST ä¸ä¸ºç©ºæ—¶: è‹¥ EH ä¸ä¸ºç©º, åˆ™ ST è¿æ¥ EH, å¦åˆ™è¿æ¥ BHã€‚ ä¸éœ€è¦å†åˆ¤æ–­ BH æ˜¯å¦ä¸ºç©ºã€‚
    - åœ¨ ET ä¸ä¸ºç©ºæ—¶, ET åªä¼šè¿æ¥ BHã€‚
    - åœ¨ BT ä¸ä¸ºç©ºæ—¶, BT å¿…é¡»è¿æ¥"ç©º"ã€‚
    - è¿æ¥å¥½å„è‡ªçš„å°¾éƒ¨å, åªéœ€è¦æ”¾å›ä¸‰æ¡é“¾è¡¨ä¸­çš„ä¸€ä¸ªå¤´èŠ‚ç‚¹å³å¯, ä¸‰ä¸ªå¤´èŠ‚ç‚¹çš„ä¼˜å…ˆçº§æ˜¯ SH > EH > BHã€‚

#### è€å¸ˆä»£ç 

```java
// æ–¹æ³•1
public static Node listPartition1(Node head, int pivot) {
    if (head == null) {
        return head;
    }
    Node cur = head;
    // è·å–é“¾è¡¨é•¿åº¦
    int i = 0;
    while (cur != null) {
        i++;
        cur = cur.next;
    }
    // å°†é“¾è¡¨è½¬æ¢ä¸ºæ•°ç»„
    Node[] nodeArr = new Node[i];
    i = 0;
    cur = head;
    for (i = 0; i != nodeArr.length; i++) {
        nodeArr[i] = cur;
        cur = cur.next;
    }
    // åœ¨æ•°ç»„ä¸Šæ‰§è¡Œ partition
    arrPartition(nodeArr, pivot);
    // å°†æ•°ç»„é‡æ–°è¿æ¥æˆé“¾è¡¨
    for (i = 1; i != nodeArr.length; i++) {
        nodeArr[i - 1].next = nodeArr[i];
    }
    nodeArr[i - 1].next = null;
    return nodeArr[0];
}

public static void arrPartition(Node[] nodeArr, int pivot) {
    int small = -1;
    int big = nodeArr.length;
    int index = 0;
    while (index != big) {
        if (nodeArr[index].value < pivot) {
            swap(nodeArr, ++small; index++);
        } else if (nodeArr[index].value == pivot) {
            index ++;
        } else {
            swap(nodeArr, --big, index);
        }
    }
}

// æ–¹æ³•2
public static Node listPartition2(Node head, int pivot) {
    // åˆ›å»ºä¸‰æ¡é“¾è¡¨, åˆ†åˆ«å­˜æ”¾ä¸‰ç±»å€¼
    Node sH = null; // small head
    Node sT = null; // small tail
    Node eH = null;
    Node eT = null;
    Node bH = null;
    Node bT = null;
    Node next = null; // save next node

    // å°†èŠ‚ç‚¹åˆ†åˆ«æ”¾å…¥ä¸‰ç±»é“¾è¡¨ä¸Š
    while (head != null) {
        next = head.next;
        head.next = null;
        if (head.value < pivot) {
            if (sH == null) {
                sH = head;
                sT = head;
            } else {
                sT.next = head;
                sT = head;
            }
        } else if (head.value == pivot) {
            if (eH == null) {
                eH = head;
                eT = head;
            } else {
                eT.next = head;
                eT = head;
            }

        } else {
            if (bH == null) {
                bH = head;
                bT = head;
            } else {
                bT.next = head;
                bT = head;
            }
        }
        head = next;
    }


    if (sT != null) {
        // è‹¥æœ‰ s, s ç›´æ¥è¿ eH
        sT.next = eH;
        // æ­¤æ—¶è¦æ˜¯ eH æ²¡æœ‰, ä¸‹ä¸€ä¸ª if ä¼šæ•è·åˆ°, å¹¶æŠŠ s é‡æ–°è¿åˆ° b
        // è¦æ˜¯ e æœ‰,                       é‚£ä¹ˆ e å°±éœ€è¦è¿åˆ° b
        // ä¹Ÿå°±æ˜¯, ä¸ç®¡ e æœ‰æ²¡æœ‰, éƒ½éœ€è¦æœ‰äººè¿æ¥åˆ° b, è¦ä¹ˆæ˜¯ s è¿, è¦ä¹ˆæ˜¯ e è¿
        eT = eT == null ? sT : eT;
        // æ­¤æ—¶çš„ eT å¯èƒ½æ˜¯ s, ä¹Ÿå¯èƒ½æ˜¯ e
    }
    // å¦‚æœä¸Šä¸€ä¸ª if è¿›å»äº†, é‚£ä¹ˆè¿™é‡Œçš„ if ä¹Ÿä¸€å®šä¼šè¿›å»
    // å¦‚æœä¸Šä¸€ä¸ª if æ²¡è¿›å», é‚£ä¹ˆè¿™é‡Œçš„ if å¯èƒ½ä¼šè¿›å»
    if (eT != null) {
        eT.next = bH;
    }

    // è¿æ¥é¡ºåºæ˜¯ s-e-b, è¦æ˜¯æ²¡æœ‰ sH, é‚£å°±è¿”å› eH, è¦æ˜¯ eH ä¹Ÿæ²¡æœ‰, é‚£å°±è¿”å› bH
    // æ‰€ä»¥å‰é¢ä¸¤ä¸ª if åªéœ€è¦ç¡®ä¿ä¸‰ä¸ªåŒºåŸŸèƒ½è¿æ¥èµ·æ¥å°±å¯ä»¥ã€‚
    return sH != null ? sH : (eH != null ? eH : bH);
}

```

#### æˆ‘çš„ä»£ç 
```py
def linked_list_partition2(head, pivot):
    # ç¨³å®š
    if head is None or head.next is None:
        return head

    # åˆ›å»ºä¸‰æ¡é“¾è¡¨, åˆ†åˆ«å­˜æ”¾å¤§äºç­‰äºå°äº
    lH, lT = None, None
    eH, eT = None, None
    mH, mT = None, None
    p = head
    while p is not None:
        if p.data < pivot:
            if lH is None:
                lH = lT = p
            else:
                lT.next = p
                lT = p
        elif p.data == pivot:
            if eH is None:
                eH = eT = p
            else:
                eT.next = p
                eT = p
        else:
            if mH is None:
                mH = mT = p
            else:
                mT.next = p
                mT = p
        p = p.next

    # å°†ä¸‰æ¡é“¾è¡¨è¿åœ¨ä¸€èµ·ã€‚ åªéœ€è¦å¯¹ tail.next è¿›è¡Œæ“ä½œ
    if lT is not None:  # lT è¦ä¹ˆè¿ eH, è¦ä¹ˆè¿ mHã€‚ (è‡ªåŠ¨åŒ…å«äº† None çš„æƒ…å†µ)
        lT.next = eH if eH is not None else mH
    if eT is not None:  # eT åªä¼šè¿ mH (è‡ªåŠ¨åŒ…å«äº† None çš„æƒ…å†µ)
        eT.next = mH
    if mT is not None:  # mT åªä¼šè¿ None
        mT.next = None

    # åªéœ€è¿”å›ä¸‰ä¸ªå¤´ä¸­çš„ä¸€ä¸ª, ä¼˜å…ˆçº§æ˜¯ lH > eH > mH
    return lH if lH is not None else (eH if eH is not None else mH)

```


### ç»ƒä¹  - å¤åˆ¶å«æœ‰éšæœºæŒ‡é’ˆèŠ‚ç‚¹çš„é“¾è¡¨

ã€é¢˜ç›®ã€‘: ä¸€ç§ç‰¹æ®Šçš„å•é“¾è¡¨èŠ‚ç‚¹ç±»æè¿°å¦‚ä¸‹
```java
class Node {
    int value;
    Node next;
    Node rand;
    Node(int val){
        value = val;
    }
}
```
rand æŒ‡é’ˆæ˜¯å•é“¾è¡¨èŠ‚ç‚¹ç»“æ„ä¸­æ–°å¢çš„æŒ‡é’ˆ, rand å¯èƒ½æŒ‡å‘é“¾è¡¨ä¸­çš„ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹, ä¹Ÿå¯èƒ½æŒ‡å‘ nullã€‚
ç»™å®šä¸€ä¸ªç”± Node èŠ‚ç‚¹ç±»å‹ç»„æˆçš„æ— ç¯å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head, è¯·å®ç°ä¸€ä¸ªå‡½æ•°å®Œæˆè¿™ä¸ªé“¾è¡¨çš„å¤åˆ¶, å¹¶è¿”å›å¤åˆ¶çš„æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹
```
   â•­ ---------- rand -------â•®
   â†“                        â†‘
â•­  â”€  â•®     â•­  â”€  â•®      â•­  â”€  â•®
â”‚     â”‚ --> â”‚     â”‚ -->  â”‚     â”‚ --> ....
â•°  â”€  â•¯     â•°  â”€  â•¯      â•°  â”€  â•¯

```
ã€è¦æ±‚ã€‘: æ—¶é—´å¤æ‚åº¦ O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦ O(1)

ã€è§£é‡Šé¢˜ç›®ã€‘: è¿™ä¸ªé“¾è¡¨å’Œæ™®é€šé“¾è¡¨çš„åŒºåˆ«åœ¨äº, ä»–å¤šäº† rand è¿™ä¸ªå±æ€§ã€‚ å½“æˆ‘ä»¬å¤åˆ¶é“¾è¡¨æ—¶, è¦æ±‚æŠŠæ¯ä¸ªèŠ‚ç‚¹ä¸Šçš„ rand çš„æŒ‡å‘ä¹ŸæˆåŠŸå¤åˆ¶ã€‚

ã€åšæ³• 1(ç¬”è®°)ã€‘: åˆ›å»ºä¸€ä¸ª Map, å®ƒçš„ key æ˜¯æ—§é“¾è¡¨èŠ‚ç‚¹, value æ˜¯æ–°èŠ‚ç‚¹(å³æ—§èŠ‚ç‚¹çš„å…‹éš†ä½“)ã€‚ å…ˆéå†ä¸€éé“¾è¡¨, å®Œæˆæ‰€æœ‰èŠ‚ç‚¹å€¼çš„æ‹·è´, æ­¤æ—¶çš„æ‹·è´å¹¶ä¸åŒ…å« next å’Œ randã€‚ å†éå†æ—§é“¾è¡¨, é€šè¿‡æ—§é“¾è¡¨è·å– next èŠ‚ç‚¹å’Œ rand èŠ‚ç‚¹, å°†æ—§é“¾è¡¨çš„èŠ‚ç‚¹ä½œä¸º key, å¯ä»¥è·å–å°±èŠ‚ç‚¹æ‰€å¯¹åº”çš„æ–°èŠ‚ç‚¹çš„åœ°å€, ç„¶åå°†æ–°èŠ‚ç‚¹çš„åœ°å€èµ‹å€¼ç»™ æ–°èŠ‚ç‚¹çš„ next å’Œ randã€‚

ã€åšæ³• 2(é¢è¯•)ã€‘:
å¦‚æœä¸å€ŸåŠ© Map ä¿å­˜å…‹éš†å‡ºæ¥çš„æ–°èŠ‚ç‚¹, é‚£ä¹ˆå°±éœ€è¦æ€è€ƒ: å…‹éš†å‡ºæ¥çš„æ–°èŠ‚ç‚¹è¦æ”¾åœ¨å“ªé‡Œèƒ½ä¸å ç”¨é¢å¤–ç©ºé—´, å¹¶ä¸”è¿˜èƒ½æ ¹æ®æ—§èŠ‚ç‚¹æ‰¾åˆ°å¯¹åº”çš„å…‹éš†èŠ‚ç‚¹?
ç­”æ¡ˆå°±æ˜¯å°†å…‹éš†èŠ‚ç‚¹æ’å…¥åˆ°æ—§èŠ‚ç‚¹ä¹‹å! å…·ä½“åšæ³•å¦‚ä¸‹:
1. ç¬¬ä¸€æ¬¡éå†é“¾è¡¨, åˆ›å»ºå…‹éš†èŠ‚ç‚¹å¹¶å°†å…¶æ’åœ¨å¯¹åº”æ—§èŠ‚ç‚¹ä¹‹å
2. ç¬¬äºŒæ¬¡éå†é“¾è¡¨, ä¸ºå…‹éš†èŠ‚ç‚¹æ‰¾åˆ°ä»–ä»¬çš„ rand èŠ‚ç‚¹æ‰€å¯¹åº”çš„å…‹éš†èŠ‚ç‚¹ã€‚ (å…‹éš† rand èŠ‚ç‚¹ åœ¨ rand èŠ‚ç‚¹çš„ next ä¸­)
3. ç¬¬ä¸‰æ¬¡éå†é“¾è¡¨, å°†å…‹éš†èŠ‚ç‚¹ä»ä¸­æŠ½å‡ºå‡ºæ¥
- æ³¨æ„: ç¬¬äºŒæ¬¡éå†é“¾è¡¨å’Œç¬¬ä¸‰æ¬¡éå†é“¾è¡¨ä¸èƒ½åˆå¹¶åœ¨ä¸€æ¬¡éå†ä¸­ã€‚ å› ä¸º rand èŠ‚ç‚¹æ˜¯éšæœºçš„, å¦‚æœæ‰¾åˆ°ä¸€ä¸ªå…‹éš†èŠ‚ç‚¹çš„ rand èŠ‚ç‚¹åå°±å°†è¯¥å…‹éš†èŠ‚ç‚¹æŠ½ç¦»å‡ºæ¥, é‚£ä¹ˆåé¢çš„èŠ‚ç‚¹å°±å¯èƒ½æ‰¾ä¸åˆ°å®ƒçš„å…‹éš† rand èŠ‚ç‚¹äº†ã€‚

```
â•­  â”€  â•®                 â•­  â”€  â•®                 â•­  â”€  â•®                 â•­  â”€  â•®                 â•­  â”€  â•®
â”‚old1 â”‚      -->        â”‚old2 â”‚      -->        â”‚old3 â”‚      -->        â”‚old4 â”‚      -->        â”‚old5 â”‚      -->        ....
â•°  â”€  â•¯                 â•°  â”€  â•¯                 â•°  â”€  â•¯                 â•°  â”€  â•¯                 â•°  â”€  â•¯
å°†æ–°å…‹éš†çš„èŠ‚ç‚¹æ”¾åˆ°æ—§é“¾è¡¨ä¸Š
â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®
â”‚old1 â”‚ --> â”‚ new1â”‚ --> â”‚old2 â”‚ --> â”‚ new2â”‚ --> â”‚old3 â”‚ --> â”‚ new3â”‚ --> â”‚old4 â”‚ --> â”‚ new4â”‚ --> â”‚old5 â”‚ --> â”‚ new5â”‚ ---> ....
â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯
```

#### è€å¸ˆä»£ç :

```java
// åšæ³•1
public static Node copyListWithRand1(Node head) {
    HashMap<Node, Node> map = new HashMap<Node, Node>();

    // ç¬¬ä¸€æ¬¡éå†: æ‹·è´æ‰€æœ‰æ—§èŠ‚ç‚¹
    Node cur = head;
    while (cur != null) {
        map.put(cur, new Node(cur.value));
        cur = cur.next;
    }

    // ç¬¬äºŒæ¬¡éå†: ä¸ºæ–°èŠ‚ç‚¹çš„ next å’Œ rand èµ‹å€¼æ–°èŠ‚ç‚¹çš„å¼•ç”¨
    cur = head;
    while (cur != null) {
        // å°†æ—§èŠ‚ç‚¹çš„ next èŠ‚ç‚¹ æ‰€å¯¹åº”çš„æ–°èŠ‚ç‚¹å¤åˆ¶ç»™æ–°èŠ‚ç‚¹çš„ next
        map.get(cur).next = map.get(cur.next);
        mpa.get(cur).rand = map.get(cur.rand);
        cur = cur.next;
    }
    return map.get(head);
}

// åšæ³•2
public static Node copyListWithRand2(Node head) {
    if (head == null) {
        return null;
    }

    // 1. å°†æ–°åˆ›å»ºçš„å…‹éš†èŠ‚ç‚¹æ”¾åˆ°æ—§é“¾è¡¨ä¸Šã€‚
    Node cur = head;
    Node next = null;
    while (cur != null) {
        next = cur.next;
        cur.next = new Node(cur.value);
        cur.next.next = next;
        cur = next;
    }

    // 2. ä¸ºæ–°åˆ›å»ºçš„å…‹éš†èŠ‚ç‚¹çš„ rand èµ‹å€¼
    cur = head;
    Node curCopy = null;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        curCopy.rand = cur.rand != null? cur.rand.next : null;
        cur = next;
    }

    // 3. å°†å…‹éš†é“¾è¡¨æŠ½ç¦»å‡ºæ¥
    Node res = head.next;
    cur = head;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = next;
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return res;

}
```

#### æˆ‘çš„ä»£ç 

```py
def copy_random_node_linked_list2(head):
    if head is None:
        return None
    # 1. åˆ›å»ºå…‹éš†èŠ‚ç‚¹å¹¶å°†å®ƒä»¬æ’å…¥åˆ°æºèŠ‚ç‚¹å
    p = head
    while p is not None:
        p_copy = Node(p.data)
        p_copy.next = p.next
        p.next = p_copy
        p = p_copy.next
    # 2. æ‰¾åˆ°å…‹éš†èŠ‚ç‚¹çš„ rand æ‰€å¯¹åº”çš„å…‹éš† rand èŠ‚ç‚¹
    p = head
    while p is not None:
        p_copy = p.next
        pn = p.next.next
        if p.rand is not None:
            p_copy.rand = p.rand.next
        p = pn
    # 3. å°†å…‹éš†èŠ‚ç‚¹æŠ½ç¦»å‡ºæ¥
    p = head
    copy_head = p.next
    while p is not None:
        p_copy = p.next
        pn = p.next.next
        p_copy.next = pn.next if pn is not None else None
        p.next = pn
        p = pn
    return copy_head
```

### ç»ƒä¹  - ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤

ã€é¢˜ç›®ã€‘: ç»™å®šä¸¤ä¸ªå¯èƒ½æœ‰ç¯ä¹Ÿå¯èƒ½æ— ç¯çš„å•é“¾è¡¨, å¤´èŠ‚ç‚¹ head1 å’Œ head2 ã€‚ è¯·å®ç°ä¸€ä¸ªå‡½æ•°, å¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤, è¯·è¿”å›ç›¸äº¤çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœä¸ç›¸äº¤, è¿”å›ç©º
ã€è¦æ±‚ã€‘: å¦‚æœä¸¤ä¸ªé“¾è¡¨é•¿åº¦ä¹‹å’Œä¸º N, æ—¶é—´å¤æ‚åº¦è¯·è¾¾åˆ° O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦è¯·è¾¾åˆ° O(1)ã€‚

å…ˆåˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦æœ‰ç¯

#### åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯

å¯¹äºé“¾è¡¨ç»“æ„, ä»–åªä¼šæœ‰ä¸€ä¸ª next èŠ‚ç‚¹ã€‚ æ‰€ä»¥:
- å¦‚æœæ— ç¯, åˆ™ä¸€å®šä¼šè¾¾åˆ°ç©º
- å¦‚æœæœ‰ç¯, åˆ™ä¸€å®šä¼šé‡åˆ°é‡å¤çš„èŠ‚ç‚¹


ã€æ–¹æ³•1ã€‘: åˆ©ç”¨ Set å“ˆå¸Œè¡¨ã€‚ éå†é“¾è¡¨, æ¯æ¬¡éå†è¿‡ç¨‹ä¸­, å…ˆåˆ¤æ–­æ˜¯å¦å·²å­˜åœ¨è¯¥èŠ‚ç‚¹, ç„¶åå°†è¯¥èŠ‚ç‚¹åŠ åˆ° Set ä¸­ã€‚å¦‚æœå·²å­˜åœ¨, åˆ™æœ‰ç¯, å¦‚æœéå†åˆ°ç©º, åˆ™æ— ç¯ã€‚

ã€æ–¹æ³•2(åªç»™æ­¥éª¤)ã€‘: æ— ç¯æ—¶, å¿«æŒ‡é’ˆç›´æ¥åˆ°ç©ºã€‚ æœ‰ç¯æ—¶, åˆ™:
- å¿«æŒ‡é’ˆæ…¢æŒ‡é’ˆéƒ½ä»å¤´èŠ‚ç‚¹å‡ºå‘, å¿«æŒ‡é’ˆä¸€æ¬¡èµ°ä¸¤æ­¥, æ…¢æŒ‡é’ˆä¸€æ¬¡èµ°ä¸€æ­¥ã€‚
- å¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆä¸€å®šä¼šç›¸é‡ã€‚ (å¹¶ä¸”ä¸€å®šåœ¨ä¸¤ç¯å†…ç›¸é‡, å³æœ‰é™æ—¶é—´å†…ç›¸é‡)
- ç›¸é‡å, å¿«æŒ‡é’ˆå›åˆ°å¤´èŠ‚ç‚¹, æ…¢æŒ‡é’ˆåœ¨åŸä½ç½®, ç„¶åä¸¤è€…åŒæ—¶ç§»åŠ¨, å¹¶ä¸”éƒ½æ˜¯ä¸€æ¬¡ä¸€æ­¥ã€‚
- ä¸¤ä¸ªæŒ‡é’ˆå†æ¬¡ç›¸é‡æ—¶, æ‰€åœ¨çš„èŠ‚ç‚¹å°±æ˜¯ç¬¬ä¸€ä¸ªç›¸äº¤èŠ‚ç‚¹(å…¥ç¯èŠ‚ç‚¹)

ã€è€å¸ˆä»£ç ã€‘:
```java
public static Node getLoopNode(Node head) {
    if (head == null || head.next == null || head.next.next == null) {
        return null;
    }
    Node n1 = head.next;  // æ…¢æŒ‡é’ˆ
    Node n2 = head.next.next; // å¿«æŒ‡é’ˆ
    while (n1 != n2) {
        if (n2.next == null || n2.next.next == null) {
            return null;
        }
        n2 = n2.next.next;
        n1 = n1.next;
    }
    n2 = head;
    while (n1 != n2) {
        n1 = n1.next;
        n2 = n2.next;
    }
    return n1;
}
```

#### åˆ¤æ–­é“¾è¡¨ç›¸äº¤

ã€æ³¨æ„ã€‘: ä¸¤æ¡é“¾è¡¨ç›¸äº¤å, ä¸€å®šä¼š"ä¸€èµ·èµ°", ä¸å¯èƒ½åˆ†å‰ã€‚ å› ä¸ºå•é“¾è¡¨èŠ‚ç‚¹åªæœ‰ä¸€ä¸ª next èŠ‚ç‚¹ã€‚

ä¸¤æ¡é“¾è¡¨ä¸‰ç§æƒ…å†µ:
- ä¸¤ä¸ªé“¾è¡¨éƒ½æ˜¯æ— ç¯é“¾è¡¨ã€‚ æ— ç¯é“¾è¡¨ç›¸äº¤, å°±ç›¸å½“äºä¸¤æ¡çº¿ç›¸äº¤, ä½†ç”±äºé“¾è¡¨åªæœ‰ä¸€ä¸ª next èŠ‚ç‚¹, æ‰€ä»¥ç›¸äº¤åä¸€å®šæ˜¯ `Y` æƒ…å†µ, è€Œä¸ä¼šå‡ºç° `X` æƒ…å†µã€‚
- ä¸€æ¡æœ‰ç¯, ä¸€æ¡æ— ç¯ã€‚ è¿™ç§æƒ…å†µä¸å¯èƒ½ç›¸äº¤ã€‚ å‡è®¾æ— ç¯é“¾è¡¨å’Œæœ‰ç¯é“¾è¡¨ç›¸äº¤, ç”±äºä¸¤ä¸ªé“¾è¡¨ç›¸äº¤åä¸€å®šä¼šåœ¨ä¸€æ¡çº¿ä¸Š, æ‰€ä»¥æ— ç¯é“¾è¡¨å°±ä¸€å®šä¼šæœ‰ç¯, è¿™ä¸å‡è®¾ä¸ç¬¦, æ•…å‡è®¾ä¸æˆç«‹ã€‚
- ä¸¤æ¡é“¾è¡¨éƒ½æœ‰ç¯ã€‚ ä¸¤æ¡æˆç¯é“¾è¡¨ç›¸äº¤, ä»–ä»¬çš„ç¯ä¸€å®šæ˜¯åŒä¸€ä¸ªã€‚ è¿™ä¸ªç¯, è¦ä¹ˆæ˜¯åœ¨ç›¸äº¤åå½¢æˆçš„, è¦ä¹ˆæ˜¯åœ¨ç›¸äº¤æˆå½¢æˆçš„ã€‚ å¦‚ä¸‹æ‰€ç¤º

```
ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€
ã€€ï¼¼ã€€ã€€ã€€ã€€ã€€ï¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ç¯çš„æ–¹å‘ä¸é‡è¦ï¼Œè°äº¤è°éƒ½ä¸€æ ·ã€€
ã€€ã€€ã€€ï¼¼ã€€ï¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€æ­¤æ—¶ç¯ç‚¹å°±æ˜¯äº¤ç‚¹ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€
ã€€ã€€ã€€ã€€ï½œã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï¼¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï¼ã€€ã€€
ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€
ã€€ã€€ã€€ã€€ï½œã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï¼¼ã€€ï¼ã€€ï¼¼ã€€ï¼ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ï¼ã€€ï¼¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï½œã€€ã€€ã€€ï½œã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ï¼¼ã€€ï¼ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ï¼¼ã€€ï¼ã€€ã€€ã€€ã€€ã€€ã€€
ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€‡ã€€ã€€ã€€ã€€ã€€ã€€ã€€
```

ã€ä¸¤æ¡ä¸æˆç¯é“¾è¡¨ç›¸äº¤æ—¶çš„äº¤ç‚¹æ±‚å–ã€‘:
- åˆ¤æ–­å°¾èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ, å¦‚æœä¸ç›¸åŒåˆ™ä¸€å®šä¸ç›¸äº¤ã€‚
- è®¡ç®—ä¸¤æ¡é“¾è¡¨çš„é•¿åº¦å·® d
- è®©é•¿çš„é“¾è¡¨ä»å¤´èŠ‚ç‚¹å…ˆèµ° d ä¸ªèŠ‚ç‚¹
- ç„¶åè®©ä¸¤ä¸ªé“¾è¡¨åŒæ—¶èµ°ä¸‹å», ä»–ä»¬è¿Ÿæ—©ä¼šç›¸é‡ã€‚

ã€ä¸¤æ¡æˆç¯é“¾è¡¨ç›¸äº¤æ—¶çš„äº¤ç‚¹æ±‚å–ã€‘:
- åˆ¤æ–­ä¸¤æ¡é“¾è¡¨çš„æˆç¯ç‚¹æ˜¯å¦ç›¸åŒ, å¦‚æœç›¸åŒè¯´æ˜ä»–ä»¬æ˜¯ç›¸äº¤åæ‰æˆç¯çš„ã€‚ å³äº¤ç‚¹ä¸€ç‚¹æ˜¯åœ¨æˆç¯å‰, æ•…ç›´æ¥ä½¿ç”¨ã€ä¸¤æ¡ä¸æˆç¯é“¾è¡¨ç›¸äº¤æ—¶çš„äº¤ç‚¹æ±‚å–ã€‘æ–¹æ³•æ±‚å–å³å¯
- æˆç¯ç‚¹ä¸åŒ, åˆ™ä¸¤æ¡é“¾è¡¨å¯èƒ½ç›¸äº¤ä¹Ÿå¯èƒ½ä¸ç›¸äº¤ã€‚
    - å¦‚æœç›¸äº¤, åˆ™è¯´æ˜æœ‰ä¸€æ¡é“¾è¡¨å…ˆæˆç¯, ç„¶åå¦ä¸€æ¡é“¾è¡¨ç›´æ¥æ’å…¥åˆ°ç¯åœˆä¸Šçš„ä¸€ä¸ªèŠ‚ç‚¹, æ¢å¥è¯è¯´, æ’å…¥çš„è¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯è¿™æ¡é“¾è¡¨çš„æˆç¯ç‚¹, åŒæ—¶ä¹Ÿæ˜¯ä»–ä»¬çš„äº¤ç‚¹ã€‚
    - å¦‚æœä¸ç›¸äº¤, åˆ™ä¸€å®šæ— æ³•å†ç¯åœˆä¸Šæ‰¾åˆ°å¦ä¸€æ¡é“¾è¡¨çš„æˆç¯ç‚¹ã€‚
    - æ•…, åªéœ€è¦åœ¨ä¸€æ¡é“¾è¡¨çš„ç¯åœˆä¸Šç»•ä¸€åœˆ, çœ‹çœ‹æ˜¯å¦æœ‰å¦ä¸€æ¡é“¾è¡¨çš„æˆç¯ç‚¹, å¦‚æœæœ‰, è¯¥ç¯ç‚¹å°±æ˜¯äº¤ç‚¹ã€‚ å¦‚æœé¥¶äº†ä¸€åœˆè¿˜æ²¡æ‰¾åˆ°, è¯´æ˜ä¸ç›¸äº¤ã€‚


ã€è€å¸ˆä»£ç ã€‘:
```java

public static  Node getIntersectNode (Node head1, Node head2) {
    if (head1 == null || head2 == null) {
        return null;
    }
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    if (loop1 == null && loop2 == null) {
        return noLoop(head1, head2);
    }
    if (loop1 != null && loop2 != null) {
        return bothLoop(head1, loop1, head2, loop2);
    }
    return null;
}

public static Node noLoop(Node head1, Node head2) {
    if (head1 == null || head2 == null) {
        return null;
    }
    Node cur1 = head1;
    Node cur2 = head2;
    int n = 0;
    while (cur1.next != null) {
        n++;
        cur1 = cur1.next;
    }
    while (cur2.next != null) {
        n--;
        cur2 = cur2.next;
    }
    if (cur1 != cur2) { // å°¾èŠ‚ç‚¹ä¸åŒ, ä¸€å®šä¸ç›¸äº¤
        return null;
    }
    cur1 = n > 0 ? head1 : head2 ; // è°é•¿, è°çš„å¤´å˜æˆ cur1
    cur2 = cur1 == head1? : head2 : head1; // è°çŸ­, è°çš„å¤´å˜æˆ cur2
    n = Math.abs(n); // ä¸¤æ¡é“¾è¡¨çš„å·®å€¼
    // å…ˆè®©é•¿é“¾è¡¨èµ°å®Œå·®å€¼çš„é•¿åº¦
    while (n != 0) {
        n--;
        cur1 = cur1.next;
    }
    // ç„¶åä¸¤ä¸ªé“¾è¡¨ä¸€èµ·èµ°, ç›¸é‡æ—¶å°±æ˜¯ç¬¬ä¸€ä¸ªäº¤å‰çš„èŠ‚ç‚¹
    while (cur1 != cur2) {
        cur1 = cur1.next;
        cur2 = cur2.next;
    }
    return cur1;
}

public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
    Node cur1 = null;
    Node cur2 = null;
    if (loop1 == loop2) {
        // è·Ÿåˆ¤æ–­ noLoop ç±»ä¼¼, ä½†åŒºåˆ«åœ¨äº noLoop åˆ¤æ–­çš„æ˜¯å°¾å·´æ˜¯ None, è€Œè¿™é‡Œåˆ¤æ–­çš„æ˜¯ loop1, loop2
        cur1 = head1;
        cur2 = head2;
        int n = 0;
        while (cur1 != loop1) {
            n++;
            cur1 = cur1.next;
        }
        while (cur2 != loop2) {
            n--;
            cur2 = cur2.next;
        }
        cur1 = n > 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        while (n != 0) {
            n--;
            cur1 = cur1.next;
        }
        while (cur1 != cur2) {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    } else {
        cur1 = loop1.next;
        while (cur1 != loop1) {
            if (cur1 == loop2) {
                return loop1; // è¿”å› loop1 æˆ– loop2 éƒ½è¡Œ, è¿™ä¸¤ä¸ªéƒ½å«åšç¬¬ä¸€ä¸ªç›¸äº¤çš„èŠ‚ç‚¹
            }
            cur1 = cur1.next;
        }
        // cur1 è½¬å®Œä¸€åœˆåéƒ½æ²¡é‡åˆ° loop2, è¯´æ˜ä¸¤ä¸ªç¯æ²¡æœ‰ç›¸äº¤
        return null;
    }
}
```
<!--
å·²è¿ç§»ï¼

## ğŸ• äºŒå‰æ ‘(èŠ‚ç‚¹å½¢å¼)


å‰é¢çš„äºŒå‰æ ‘, æ˜¯æ•°ç»„å½¢å¼çš„, è¿™é‡Œçš„äºŒå‰æ ‘, æ˜¯èŠ‚ç‚¹å½¢å¼çš„ã€‚ èŠ‚ç‚¹ç»“æ„å¦‚ä¸‹:
```java
class Node<V> {
    V value;
    Node left;
    Node right;
}
```

### é€’å½’éå†

é€’å½’åº: é€’å½’éå†äºŒå‰æ ‘æ—¶, æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸‰ä¸ªç‰¹æ®Šæ—¶åˆ»
- 1ï¸âƒ£ åˆæ¬¡è¿›å…¥å½“å‰èŠ‚ç‚¹
- 2ï¸âƒ£ éå†å®Œå·¦å­èŠ‚ç‚¹åè¿”å›å½“å‰èŠ‚ç‚¹
- 3ï¸âƒ£ éå†å®Œå³å­èŠ‚ç‚¹åè¿”å›å½“å‰èŠ‚ç‚¹

```py
def f(root):
    if root is None:
        return
    # 1ï¸âƒ£ åˆæ¬¡è¿›å…¥å½“å‰èŠ‚ç‚¹

    f(root.left)
    # 2ï¸âƒ£ éå†å®Œå·¦å­èŠ‚ç‚¹åè¿”å›å½“å‰èŠ‚ç‚¹

    f(root.right)
    # 3ï¸âƒ£ éå†å®Œå³å­èŠ‚ç‚¹åè¿”å›å½“å‰èŠ‚ç‚¹
```

åœ¨è¿™ä¸‰ä¸ªç‰¹æ®Šçš„æ—¶åˆ», åšå¯¹åº”çš„æ“ä½œ, å°†ä¼šæœ‰ä¸åŒçš„ç‰¹ç‚¹ã€‚ æ¯”å¦‚åœ¨è¿™ä¸‰ä¸ªç‰¹æ®Šçš„æ—¶åˆ»æ‰“å°å½“å‰èŠ‚ç‚¹å€¼:
- 1ï¸âƒ£ æ—¶åˆ»æ‰“å°èŠ‚ç‚¹å€¼ä¸º **å…ˆåº**éå†(pre-order): **å¤´**å·¦å³ã€‚
- 2ï¸âƒ£ æ—¶åˆ»æ‰“å°èŠ‚ç‚¹å€¼ä¸º **ä¸­åº**éå†(in-order): å·¦**å¤´**å³ã€‚
- 3ï¸âƒ£ æ—¶åˆ»æ‰“å°èŠ‚ç‚¹å€¼ä¸º **ååº**éå†(post-order): å·¦å³**å¤´**ã€‚


### éé€’å½’éå†

æœ€å¼€å§‹çš„ç¨‹åºéƒ½æ˜¯ä¸æ”¯æŒé€’å½’çš„, ä¹‹åçš„ç³»ç»Ÿä¹Ÿæ˜¯åˆ©ç”¨æ ˆå®ç°çš„é€’å½’, æ‰€ä»¥ä»»ä½•é€’å½’éƒ½å¯ä»¥æ”¹æˆéé€’å½’, åªä¸è¿‡æ˜¯è‡ªå·±ç®¡ç†æ ˆçš„é—®é¢˜ç½¢äº†ã€‚

ä¸ºä»€ä¹ˆéé€’å½’éå†æ˜¯é‡ç‚¹:
- é€’å½’éå†å¤ªç®€å•äº†ã€‚
- éé€’å½’éå†èƒ½å¤Ÿè®©ä½ æ›´ç†Ÿæ‚‰äºŒå‰æ ‘ç»“æ„
- éé€’å½’å¯ä»¥èŠ‚çœç©ºé—´, å› ä¸ºç³»ç»Ÿæ ˆç®¡ç†çš„æ˜¯å‡½æ•°, è‡ªå·±åˆ›å»ºçš„æ ˆå¯ä»¥è‡ªå®šæŒ‡å®šå…ƒç´ å¤§å°å’Œç±»å‹ã€‚
- éé€’å½’æ‰§è¡Œæ•ˆç‡æ›´é«˜, é€’å½’æ¶‰åŠå‡½æ•°è°ƒç”¨å’Œä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€, è€Œéé€’å½’ç›´æ¥é€šè¿‡å¾ªç¯å®ç°ã€‚

ã€å…³é”®ç‚¹ã€‘: èŠ‚ç‚¹å½¢å¼çš„äºŒå‰æ ‘, è®¿é—®ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹, éƒ½ **å¿…é¡»é€šè¿‡å¤´èŠ‚ç‚¹** è®¿é—®ã€‚ ç‰¢è®°è¿™ä¸€ç‚¹å¯ä»¥æ›´å¥½çš„ç†è§£ä¸‹é¢éé€’å½’çš„å†™æ³•ã€‚

#### å…ˆåº(pre-order)

å¯¹æ¯ä¸€é¢—å­æ ‘, éƒ½æ˜¯å…ˆæ‰“å° "å¤´", ç„¶åæ‰“å°å·¦, å†æ‰“å°å³ã€‚
é‡ç‚¹åœ¨äº, æ‰“å° "å·¦" æ—¶, è¿™ä¸ª å·¦å­èŠ‚ç‚¹ åŒæ—¶ä¹Ÿæ˜¯ å¤´èŠ‚ç‚¹ã€‚ æ‰€ä»¥æ‰“å°å®Œè¿™ä¸ª å·¦å­èŠ‚ç‚¹ åè¿˜è¦ç»§ç»­å¾€å·¦è¾¹æ‰“å°ã€‚

å½“æˆ‘ä»¬æ‰“å°å¤´å, å¤´èŠ‚ç‚¹å°±åªå‰©ä¸‹ "å¸®åŠ©æˆ‘ä»¬æ‰¾åˆ°å·¦å³ä¸¤ä¸ªå­èŠ‚ç‚¹" è¿™ä¸€ä¸ªä½¿å‘½, å¦‚æœå®Œæˆäº†è¿™ä¸ªä½¿å‘½, é‚£ä¹ˆå¤´èŠ‚ç‚¹å°±æ²¡ç”¨äº†ã€‚
è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥ä¸å­˜å‚¨å¤´èŠ‚ç‚¹çš„ä¿¡æ¯ã€‚ (è¿™å°±æ˜¯å’Œé€’å½’ä¸åŒçš„åœ°æ–¹, é€’å½’å®ç°ä¸­, å¤´èŠ‚ç‚¹æ°¸è¿œä½äºæ ˆçš„æœ€åº•ç«¯, è€Œè‡ªå·±å®ç°æ—¶, å®Œå…¨å¯ä»¥å°†å¤´èŠ‚ç‚¹è¸¢å‡ºå»)ã€‚

æ•…éé€’å½’å®ç°å‰åºéå†çš„æœ¬è´¨å°±æ˜¯: ç”¨ä¸€ä¸ª "å¤´", æ¢ä¸¤ä¸ª "å­"ã€‚
- å¤´å‡ºæ ˆ, ç„¶åå°†ä¸¤ä¸ªå­èŠ‚ç‚¹å…¥æ ˆã€‚ å¤´å…ˆå‡ºæ ˆ, å…å¾—å ç”¨ç©ºé—´ã€‚ åŒæ—¶å¤´å‡ºæ ˆåç›´æ¥æ‰“å°ã€‚
- å…ˆå‹å³èŠ‚ç‚¹, å†å‹å·¦èŠ‚ç‚¹ã€‚ å› ä¸ºæ ˆçš„ç»“æ„æ˜¯å…ˆè¿›åå‡º, æˆ‘ä»¬æ˜¯åœ¨å‡ºæ ˆæ—¶æ‰“å°, æ‰€ä»¥è¦åå‹å·¦èŠ‚ç‚¹, æ‰èƒ½å®ç°å…ˆæ‰“å°å·¦èŠ‚ç‚¹


```py
def pre_order_binary_tree(root, print_arr):
    stack = [root]
    while len(stack) != 0:
        head = stack.pop() # å¤´èŠ‚ç‚¹çš„ä½¿å‘½(æ‰“å°, æ‰¾åˆ°å­èŠ‚ç‚¹)åœ¨ä¸€ä¸ªå¾ªç¯ä¸­å°±èƒ½å®Œæˆ, æ‰€ä»¥ä¸éœ€è¦ç»§ç»­ä¿å­˜å¤´èŠ‚ç‚¹
        print_arr.append(head.val)
        # æˆ‘ä»¬æ˜¯åœ¨å‡ºæ ˆæ—¶æ‰“å°, æ‰€ä»¥å…ˆæ‰“å°çš„ä¸œè¥¿è¦åå‹æ ˆ, åæ‰“å°çš„ä¸œè¥¿è¦å…ˆå‹æ ˆ
        stack.append(head.right) if head.right is not None else None
        stack.append(head.left) if head.left is not None else None
```

#### ååº(post-order)

ååºéå†, å·¦å³**å¤´**ã€‚ ä»–å…¶å®æ˜¯å…ˆåºæ‰“å°çš„å˜ä½“ã€‚
å…ˆåºæ‰“å°ä¸­, å¤´å‡ºæ ˆæ—¶å°±æ‰“å°, ç„¶åå…ˆå³åå·¦, ç»“æœå°±æ˜¯ å¤´å·¦å³ã€‚
å°†å…ˆåºæ‰“å°æ”¹æˆè¿™æ ·: å¤´å‡ºæ ˆæ—¶æ‰“å°, ç„¶åå‹æ ˆé¡ºåºå˜ä¸ºå…ˆå·¦åå³, é‚£ç»“æœå°±ä¼šå˜æˆ å¤´å³å·¦ã€‚
æˆ‘ä»¬ä¼šå‘ç°è¿™ä¸ªé¡ºåºåˆšå¥½å’Œ ååºéå†çš„é¡ºåºç›¸å, æ‰€ä»¥åªè¦æˆ‘ä»¬å°† "æ‰“å°" è¿™ä¸ªæ“ä½œæ¢æˆ "å…¥å¦å¤–ä¸€ä¸ªæ ˆ",
ç„¶åç­‰å¾…ç»“æŸå, å†å°†å¦å¤–ä¸€ä¸ªæ ˆä¸­çš„å†…å®¹å–å‡º, å°±å®ç°äº†ååºéå†ã€‚

```py
def pos_order_binary_tree(root, print_arr):
    stack = [root]
    collect = [] # æ”¶é›†è¦è¦æ‰“å°çš„å…ƒç´ 
    while len(stack) != 0:
        head = stack.pop()
        collect.append(head) # å°†æ‰“å°æ¢æˆå…¥æ ˆ
        # å‹æ ˆé¡ºåºå˜ä¸ºå…ˆå·¦åå³
        stack.append(head.left) if head.left is not None else None
        stack.append(head.right) if head.right is not None else None
    # å‰é¢å’Œå…ˆåºéå†ä¸€æ ·, ç„¶åå°†å†…å®¹ä»æ ˆä¸­
    while len(collect) != 0:
        print_arr.append(collect.pop().val)
```

#### ä¸­åº(in-order)

ä¸­åºéå†ä¸­, å¤´èŠ‚ç‚¹çš„ä½¿å‘½ä¾æ—§æœ‰ä¸¤ä¸ª: æ‰“å° + æ‰¾åˆ°ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚
ä½†å› ä¸ºä¸­åºéå†æ˜¯ å·¦**å¤´**å³, è€Œæˆ‘ä»¬é€‰æ‹©åœ¨å‡ºæ ˆæ—¶æ‰“å°, æ‰€ä»¥åœ¨æ²¡æœ‰æ‰“å°"å·¦"ä¹‹å‰, å¤´å¿…é¡»å¾…åœ¨æ ˆä¸­ã€‚
ç›´åˆ°"å·¦"å‡ºæ ˆå, å¤´æ‰å¯ä»¥å‡ºæ ˆ, åŒæ—¶å°†"å³"å…¥æ ˆ(ç»™å‡ºå³çš„ä½ç½®)ã€‚

æ‰€ä»¥ä¸­åºéå†ç®—æ³•å¦‚ä¸‹:
- å°†å·¦å­èŠ‚ç‚¹å‹æ ˆ ("å¤´" ç»™å‡º "å·¦" çš„ä½ç½®)
- "å·¦"ä¸ºç©ºæ—¶, "å¤´" å‡ºæ ˆ, åŒæ—¶å°† "å³" å‹æ ˆ (ç»™å‡º "å³" ä½ç½®)ã€‚

å¦‚æœè¿˜ä¸ç†è§£, è‡ªå·±ç”»ä¸€ä¸‹æ ˆçš„å˜åŒ–å›¾ã€‚

```py
def in_order_binary_tree(root, print_arr):
    stack = []
    p = root
    # æ ˆç©ºæ—¶, è¡¨ç¤ºæ ¹èŠ‚ç‚¹çš„å·¦éƒ¨éƒ½å®Œæˆäº†, æ­¤æ—¶ p ä¸ºæ ¹èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ã€‚ æ‰€ä»¥è¿˜ä¸å¯ä»¥å‡ºæ ˆ
    while len(stack) != 0 or p is not None:
        if p is not None:
            # ä¸æ–­å°†å·¦è¾¹ç•Œå‹æ ˆ
            stack.append(p)
            p = p.left
        else:
            # å·¦è¾¹ç•Œå‹å®Œäº†, "å¤´" çš„ä½¿å‘½ä¹Ÿå°±ç»“æŸäº†, äºæ˜¯ "å¤´" å‡ºæ ˆ
            p = stack.pop()
            print_arr.append(p.val)
            # åŒæ—¶ "å¤´" ç»™å‡ºå³å­èŠ‚ç‚¹çš„ä½ç½®
            p = p.right
```

ã€ä¸ºä»€ä¹ˆè¿™æ ·èƒ½å¤Ÿå®ç°ååºéå†ã€‘:
ä¸€æ£µæ ‘å¯ä»¥åˆ†è§£ä¸ºè‹¥å¹²ä¸ªå·¦æ ‘, ä¸åŒå·¦æ ‘ä¹‹é—´, æˆ‘ä»¬å…ˆå¤„ç†å·¦è¾¹çš„å·¦æ ‘ã€‚
åœ¨å¤„ç†å·¦æ ‘æ—¶, æˆ‘ä»¬æ˜¯å…ˆè‡ªä¸Šåˆ°ä¸‹å°†æ‰€æœ‰å·¦å­èŠ‚ç‚¹å…¥æ ˆ, ç„¶åå†å‡ºæ ˆæ‰“å°, æ‰€ä»¥æ‰“å°çš„é¡ºåºæ˜¯å…ˆå·¦åå¤´ã€‚
åˆå› ä¸ºå·¦è¾¹çš„å·¦æ ‘å§‹ç»ˆæ¯”å³è¾¹çš„å·¦æ ‘å…ˆå¤„ç†, è€Œå¤„ç†å®Œå·¦æ ‘çš„åŒæ—¶ä¹Ÿä¼šæ‰“å°å¤´, æ‰€ä»¥æœ€ç»ˆæ˜¯å·¦å¤´å³çš„é¡ºåºã€‚
å¯¹äºä»»ä½•ä¸€æ£µå­æ ‘, éƒ½æ˜¯è®©ä»–å…ˆå·¦å†å¤´, ç„¶ååœ¨ä»–çš„å³æ ‘ä¸Š, ç»§ç»­å…ˆå·¦å†å¤´ã€‚ æ‰€ä»¥æœ€ç»ˆæ˜¯
```
ã€€ã€€ã€€ã€€ã€€ã€€å·¦å¤´å³
ã€€ã€€ã€€ã€€ã€€å·¦ã€€ã€€å·¦å¤´å³
ã€€ã€€ã€€ã€€å·¦ã€€ã€€å·¦ã€€ã€€å·¦å¤´å³
ã€€ã€€ã€€å·¦ã€€ã€€å·¦ã€€ã€€å·¦ã€€ã€€å·¦å¤´å³
ã€€ã€€å·¦ã€€ã€€å·¦ã€€ã€€å·¦ã€€ã€€ã€€ã€€ã€€...
```

### å±‚åº(å®½åº¦)éå†

ã€æ­¥éª¤ã€‘:
- åˆ©ç”¨é˜Ÿåˆ—, åˆå§‹æ—¶é˜Ÿåˆ—é‡Œæ˜¯å¤´èŠ‚ç‚¹ã€‚
- ä¸æ–­ä»é˜Ÿåˆ—ä¸­å¼¹å‡ºä¸€ä¸ªèŠ‚ç‚¹
    - å¼¹å‡ºèŠ‚ç‚¹æ—¶, å¤„ç†å°†è¯¥èŠ‚ç‚¹(æ‰“å°)
    - åŒæ—¶å°†è¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹, å³èŠ‚ç‚¹æŒ‰åºåŠ å…¥é˜Ÿåˆ—ä¸­

```py
from queue import Queue
def levelOrder(root):
    if root is None:
        return
    queue = Queue()
    queue.put(root)
    while not queue.empty():
        cur = queue.get()
        print(cur.val)
        if cur.left is not None:
            queue.put(cur.left)
        if cur.right is not None:
            queue.put(cur.right)
```

### äºŒå‰æ ‘æœ€å¤§å®½åº¦

ã€åšæ³•1ã€‘:
- åˆ©ç”¨å“ˆå¸Œè¡¨ç»Ÿè®¡æ¯ä¸ªèŠ‚ç‚¹çš„å±‚æ•°ã€‚ å³: åœ¨å°†èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—æ—¶è®°å½•è¯¥èŠ‚ç‚¹çš„å±‚æ•°, æ–°åŠ èŠ‚ç‚¹çš„å±‚æ•° = å½“å‰èŠ‚ç‚¹å±‚æ•°+1ã€‚ å› ä¸ºæ–°åŠ èŠ‚ç‚¹æ˜¯å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹
- æ¯æ¬¡å¼¹å‡ºèŠ‚ç‚¹æ—¶, åˆ¤æ–­è¯¥èŠ‚ç‚¹æ˜¯å¦åœ¨å½“å‰å±‚, ä¸è¿‡ä¸æ˜¯, è¯´æ˜å·²ç»è¿›å…¥ä¸‹ä¸€å±‚äº†, æ­¤æ—¶å¯ä»¥ç»Ÿè®¡ä¸Šä¸€å±‚çš„èŠ‚ç‚¹æ•°ã€‚

ã€åšæ³•2ã€‘:
åšæ³•1ä¸­çš„å“ˆå¸Œè¡¨å­˜å‚¨äº†å¾ˆå¤šå¤šä½™ä¿¡æ¯ã€‚ å½“ä½ è¿›å…¥ä¸‹ä¸€å±‚æ—¶, "ä¸Šä¸€å±‚èŠ‚ç‚¹æ‰€å¯¹åº”çš„å±‚æ•°"è¿™ä¸ªä¿¡æ¯å°±æ˜¯ä¸éœ€è¦çš„äº†ã€‚
å› ä¸ºæˆ‘ä»¬ç»Ÿè®¡çš„æ˜¯æœ€å¤§å±‚æ•°, è€Œæˆ‘ä»¬ç”±æ˜¯ä»ç¬¬ä¸€å±‚æ…¢æ…¢èµ°åˆ°æœ€åä¸€å±‚çš„, æ‰€ä»¥æˆ‘ä»¬çœŸæ­£éœ€è¦çš„å­˜å‚¨çš„åªæœ‰å½“å‰å±‚çš„èŠ‚ç‚¹æ•°é‡å’Œå½“å‰æœ€å¤§å®½åº¦ã€‚
å…¶ä»–ä¿¡æ¯éƒ½æ˜¯è¾…åŠ©ä½œç”¨, éƒ½åº”è¯¥å¯ä»¥æœ€å°åŒ–ä»–ä»¬çš„å­˜å‚¨ç©ºé—´ã€‚
ã€åšæ³•2å…·ä½“å®ç°ã€‘:
åˆ©ç”¨ä¸‰ä¸ªå˜é‡ä»£æ›¿å“ˆå¸Œè¡¨ã€‚ è¿™ä¸‰ä¸ªå˜é‡åˆ†åˆ«è®°å½• å½“å‰å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ `curEnd`, ä¸‹ä¸€å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ `nextEnd`, å½“å‰å±‚çš„èŠ‚ç‚¹æ•°é‡ `curNodes`ã€‚
- åˆå§‹æ—¶, `curEnd` ä¸ºå¤´èŠ‚ç‚¹; `nextEnd` ä¸ºç©º; `curNodes` ä¸º 0, å› ä¸ºå¤´èŠ‚ç‚¹è¿˜æœªå¼¹å‡º, å½“å‰å±‚è¿˜æœªç»Ÿè®¡å®Œã€‚
- é˜Ÿåˆ—å¼¹å‡ºä¸€ä¸ªèŠ‚ç‚¹æ—¶, ä¼šå°†ä»–çš„å­èŠ‚ç‚¹åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ã€‚
    - å¼¹å‡ºä¸€ä¸ªèŠ‚ç‚¹æ—¶, åˆ¤æ–­è¯¥èŠ‚ç‚¹æ˜¯å¦æ˜¯ `curEnd` èŠ‚ç‚¹ã€‚
        - å¦‚æœä¸æ˜¯, è¯´æ˜è¯¥èŠ‚ç‚¹è¿˜åœ¨å½“å‰å±‚, å°† `curNodes` +1
        - å¦‚æœæ˜¯, è¯´æ˜å½“å‰å±‚èŠ‚ç‚¹æ•°ç»Ÿè®¡ç»Ÿè®¡å®Œæ¯•, å°† `curNodes` +1 åæ›´æ–°æœ€å¤§å®½åº¦ maxã€‚ ç„¶å `curEnd` ä¿®æ”¹ä¸º `nextEnd`, åŒæ—¶ `nextEnd` ä¸ºç©ºã€‚ å› ä¸ºä¸‹ä¸€æ¬¡å°†ä¼šè¿›å…¥ä¸‹ä¸€å±‚äº†ã€‚
    - å°†å­èŠ‚ç‚¹åŠ å…¥åˆ°é˜Ÿåˆ—æ—¶, æ›´æ–° `nextEnd` ä¸ºè¯¥å­èŠ‚ç‚¹ã€‚ å› ä¸ºå­èŠ‚ç‚¹æ˜¯ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹, æˆ‘ä»¬åŠ å…¥çš„é¡ºåºæ˜¯ä»å·¦åˆ°å³çš„, ä¸æ–­çš„æ›´æ–° `nextEnd`, ä¸‹ä¸€å±‚æœ€åä¸€ä¸ªèŠ‚ç‚¹ä¸€å®šä¼šæ˜¯æœ€åä¸€ä¸ªèµ‹å€¼ç»™ `nextEnd` çš„ã€‚


ã€ä»£ç ã€‘:
```py
# åšæ³•1
def binary_tree_max_width1(root):
    max_w = 0 # æœ€å¤§å®½åº¦
    if root is None:
        return max_w
    queue = Queue()
    queue.put(root)

    level_map = {} # å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„å±‚æ•°
    level_map[root] = 1 # root çš„å±‚æ•°æ˜¯ç¬¬ä¸€å±‚
    store_level = 1 # è®°å½•å¼¹å‡ºå…ƒç´ å‰ä½äºç¬¬å‡ å±‚
    store_w = 0 # ç»Ÿè®¡å½“å‰å±‚å®½åº¦ã€‚ å¼¹å‡ºå…ƒç´ æ—¶åŠ  1
    while not queue.empty():
        cur = queue.get()
        if store_level == level_map[cur]:
            # è¿˜åœ¨åŒä¸€å±‚, å®½åº¦(èŠ‚ç‚¹æ•°)åŠ 1
            store_w += 1
        else:
            # å¼¹å‡ºå…ƒç´ å±‚çº§å’Œè®°å½•çš„å±‚çº§ä¸åŒ, è¯´æ˜å½“å‰å¾ªç¯å·²ç»è¿›å»ä¸‹ä¸€å±‚
            store_level += 1
            max_w = max(store_w, max_w)
            store_w = 1 # æ–°ä¸€å±‚çš„ç¬¬ä¸€ä¸ªå…ƒç´ å·²ç»å¼¹å‡º

        # å‰é¢ä»£ç èƒ½æˆç«‹çš„æ¡ä»¶æ˜¯, é€šè¿‡ map åŒç†äº†æ¯ä¸ªèŠ‚ç‚¹çš„å±‚æ•°
        if cur.left is not None:
            # åœ¨å°†æ–°èŠ‚ç‚¹åŠ åˆ°é˜Ÿåˆ—ä¸­æ—¶, å­˜å‚¨è¯¥èŠ‚ç‚¹çš„å¯¹åº”å±‚æ•°; è¯¥èŠ‚ç‚¹çš„å±‚æ•°ç­‰äºå…¶çˆ¶èŠ‚ç‚¹çš„å±‚æ•°+1
            level_map[cur.left] = level_map[cur] + 1
            queue.put(cur.left)
        if cur.right is not None:
            level_map[cur.right] = level_map[cur] + 1
            queue.put(cur.right)
    # éå†å®Œæœ€åä¸€å±‚å, å†"ç»“ç®—"ä¸€ä¸‹ã€‚
    max_w = max(store_w, max_w)
    return max_w

# åšæ³•2
def binary_tree_max_width2(root):
    max_w = 0
    if root is None:
        return max_w

    queue = Queue()  # åˆ©ç”¨é˜Ÿåˆ—å®ç°å±‚çº§éå†
    queue.put(root)  # é˜Ÿåˆ—åˆå§‹å€¼ä¸ºæ ¹èŠ‚ç‚¹ã€‚ åç»­é€šè¿‡åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºæ¥é€€å‡ºå¾ªç¯
    cur_end = root  # å½“å‰å±‚çš„æœ€åèŠ‚ç‚¹
    next_end = None  # ä¸‹ä¸€å±‚çš„æœ€åèŠ‚ç‚¹
    cur_w = 0 # å½“å‰å±‚èŠ‚ç‚¹æ•°é‡

    while not queue.empty(): # é˜Ÿåˆ—ä¸ºç©º, åˆ™éå†å®Œæ¯•
        # æ¯æ¬¡éƒ½å¼¹å‡ºä¸€ä¸ªå…ƒç´ 
        cur = queue.get()
        cur_w += 1
        # å¼¹å‡ºä¸€ä¸ªå…ƒç´ çš„åŒæ—¶, æŒ‰ä»å·¦åˆ°å³çš„æ¬¡åºä¾æ¬¡å°†å­èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­
        if cur.left is not None:
            next_end = cur.left # ä¸‹ä¸€å±‚çš„æœ€åèŠ‚ç‚¹åœ¨åŠ å…¥å­èŠ‚ç‚¹çš„è¿‡ç¨‹ä¸­äº§å‡º, è°ç•™åˆ°æœ€åè°å°±æ˜¯ä¸‹å±‚æœ€åèŠ‚ç‚¹
            queue.put(cur.left)
        if cur.right is not None:
            next_end = cur.right
            queue.put(cur.right)
        # åˆ¤æ–­å¼¹å‡ºçš„å…ƒç´ æ˜¯å¦æ˜¯å½“å‰å±‚æœ€åèŠ‚ç‚¹
        if cur is cur_end:
            # å¦‚æœæ˜¯, åˆ™æ•´ç†å½“å‰å±‚ä¿¡æ¯
            max_w = max(max_w, cur_w)
            # åŒæ—¶å‡†å¤‡ä¸‹ä¸€å±‚ä¿¡æ¯
            cur_w = 0
            cur_end = next_end
            next_end = None

    return max_w
```

-->
