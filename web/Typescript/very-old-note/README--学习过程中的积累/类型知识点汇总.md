## 🍕 疑问

### 情景1

**描述**: 现在有 `a`, `b`, `c` 三个属性,
要求定义一个类型, 该类型能够限制一个对象只能有一个属性,
并且该属性必须是 `a`, `b`, `c` 三者之中的一个


## 🍕 知识点

- `Definitely Typed` 是最受欢迎的声明文件存储库。
- 当一个类扩展另一个类，并替换其父类的成员时，它被称为 `override` （覆盖）

## 🍕 不确定是否是最优解的类型定义

### 案例1

```html
  <div @mousedown="startDrag" @touchstart="startDrag"></div>
```

js 代码:

```js
function startDrag(e) {
  e = e.changedTouches ? e.changedTouches[0] : e
  isDragging = true
  start.x = e.pageX
  start.y = e.pageY
}
```

转换为 ts 代码

```ts
function startDrag(e: MouseEvent | TouchEvent) {
  // MouseEvent | Touch 可替换成 {pageY:number, pageX:number}
  const _e : MouseEvent | Touch = (e as TouchEvent).changedTouches ? (e as TouchEvent).changedTouches[0] : (e as MouseEvent)
  isDragging = true
  start.x = _e.pageX
  start.y = _e.pageY
}
```

总感觉有更好的处理方式


## 🍕 常规报错积累

### 元素隐式具有 "any" 类型，因为类型为 "string" 的表达式不能用于索引类型

下面的代码不一定会报错,
我这是在 `tsconfig.json` 开启了 `"strict": true,`,
即不允许出现隐式的 `any` 类型, 所以才会报错

```ts
interface G { a: string }
const row: G = { a: '' }
Object.keys(row).some(key => {
  row[key] // ❌ 元素隐式具有 "any" 类型，因为类型为 "string" 的表达式不能用于索引类型 "G"。在类型 "G" 上找不到具有类型为 "string" 的参数的索引签名。ts(7053)
  row[(key as keyof G)] // ✔️
})
```

### 无法重新声明块范围变量“user”。

  在 ts 中，如果没有将文件作为 `module` 导出，则这些非模块的文件代码都是在同一个作用域中的。
  可以显式的声明 `export`, 这样就不在同一个作用域中了。

### 无法找到模块 “xxx” 的声明文件 xxx 隐式拥有 “any“ 类型

  在 `vite-env.d.ts` 文件中声明该模块:

  ```ts
  declare module '@/script/xxx'
  ```

  注意, 如果导入时带上了后缀, 则声明模块时也带上后缀.

  如果没有 `vite-env.d.ts` 文件, 则在 `src` 文件夹下自己创建一个 `.d.ts` 的文件.
  同时要确保 `tsconfig.json` 文件中能够识别到新创建的文件:

  ```json
  "include": ["src/**/*.d.ts"],
  ```